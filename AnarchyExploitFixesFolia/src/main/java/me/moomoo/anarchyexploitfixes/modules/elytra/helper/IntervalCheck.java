package me.moomoo.anarchyexploitfixes.modules.elytra.helper;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.threadedregions.scheduler.ScheduledTask;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.utils.LocationUtil;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import java.time.Duration;
import java.util.UUID;

public class IntervalCheck extends ElytraHelper {

    public ScheduledTask scheduledTask;
    public final Cache<UUID, Double> PLAYER_SPEEDS;
    public final Cache<UUID, Location> LAST_GLIDE_POS;
    private final int checkIntervalTicks;
    public final boolean isEnabled;

    public IntervalCheck() {
        Config config = AnarchyExploitFixes.getConfiguration();
        this.isEnabled = config.getBoolean("elytra.patch-generic-speedhacks.enable", true,
                "Patches speed-limit bypass using generic speedhacks (Timer) by additionally checking player position every x ticks");
        final int tickInterval = config.getInt("elytra.patch-generic-speedhacks.check-interval-in-ticks", 10,
                "Lower value means more accuracy but also more overhead.");
        this.checkIntervalTicks = Math.max(tickInterval, 1);
        final Duration cacheTime = Duration.ofMillis(Math.max(1000, (tickInterval * 50L) + 100L));
        this.PLAYER_SPEEDS = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        this.LAST_GLIDE_POS = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
    }

    public void startIfEnabled() {
        if (isEnabled) this.scheduledTask = super.plugin.getServer().getGlobalRegionScheduler().runAtFixedRate(plugin,
                scheduleChecks -> this.run(), checkIntervalTicks, checkIntervalTicks);
    }

    public void stopIfEnabled() {
        if (scheduledTask != null) scheduledTask.cancel();
    }

    private void run() {
        for (Player player : super.plugin.getServer().getOnlinePlayers()) {
            player.getScheduler().run(plugin, checkFlight -> {
                if (super.isGliding(player)) {
                    Location currentLocation = player.getLocation().clone();
                    Location lastLocation = this.LAST_GLIDE_POS.getIfPresent(player.getUniqueId());
                    if (lastLocation != null) this.PLAYER_SPEEDS.put(player.getUniqueId(),
                            LocationUtil.getRelDistance3D(lastLocation, currentLocation) / checkIntervalTicks);
                    this.LAST_GLIDE_POS.put(player.getUniqueId(), currentLocation);
                }
            }, null);
        }
    }
}
