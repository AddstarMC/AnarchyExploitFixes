package me.moomoo.anarchyexploitfixes.modules.patches;

import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import net.kyori.adventure.text.minimessage.MiniMessage;
import org.bukkit.block.ShulkerBox;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.*;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.jetbrains.annotations.Nullable;

import java.nio.charset.StandardCharsets;

public class BookBan implements AnarchyExploitFixesModule, Listener {

    private final MiniMessage miniMessage;
    private final int maxBookSize, maxItemSize, maxInventorySize;

    public BookBan() {
        shouldEnable();
        this.miniMessage = MiniMessage.miniMessage();
        Config config = AnarchyExploitFixes.getConfiguration();
        this.maxBookSize = config.getInt("patches.anti-book-ban.max-book-size", 9000);
        this.maxItemSize = config.getInt("patches.anti-book-ban.max-item-size", 8260);
        this.maxInventorySize = config.getInt("patches.anti-book-ban.max-inventory-size", 50674);
    }

    @Override
    public String name() {
        return "prevent-book-ban";
    }

    @Override
    public String category() {
        return "patches";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("patches.anti-book-ban.enable", true);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    private long getItemSize(@Nullable ItemStack stack) {
        long byteSize = 0L;
        if (stack == null) return byteSize;

        if (
                stack.hasItemMeta()
                && stack.getItemMeta() instanceof BlockStateMeta blockStateMeta
                && blockStateMeta.getBlockState() instanceof ShulkerBox shulkerBox
        ) {
            byteSize += getInventorySize(shulkerBox.getInventory());
        }

        // The serialize as bytes function takes significantly longer to run because
        // it tries to compress the file. Instead, we will just use the string length,
        // even though that is not a great proxy.
        byteSize += stack.serialize().toString().getBytes(StandardCharsets.UTF_8).length;

        return byteSize;
    }

    private long getInventorySize(@Nullable final Inventory inventory) {
        long size = 0L;
        if (inventory != null) {
            for (ItemStack stack : inventory) {
                size += getItemSize(stack);
            }
        }
        return size;
    }

    // Prevent players from creating big books
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBookEdit(PlayerEditBookEvent event) {
        // Map using MiniMessage#serialize so there are no possible bypasses using large components.
        final String serializedPages = String.join("", event.getNewBookMeta().pages().stream().map(miniMessage::serialize).toList());
        if (
                serializedPages.getBytes(StandardCharsets.UTF_8).length > maxBookSize
                || serializedPages.getBytes(StandardCharsets.UTF_16).length > maxBookSize
        ) {
            event.setCancelled(true);
        }
    }

    // Attempt to stop players from picking up large items
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        final long itemSize = getItemSize(event.getItem().getItemStack());
        if (itemSize > maxItemSize) {
            event.setCancelled(true);
            return;
        }

        // Check if the total inventory size would be larger than the maximum inventory size
        if (itemSize + getInventorySize(event.getPlayer().getInventory()) > maxInventorySize) {
            event.setCancelled(true);
        }
    }

    private void sanitizeInventory(PlayerInventory inventory) {
        for (ItemStack item : inventory) {
            if (getItemSize(item) > maxItemSize) {
                item.subtract(item.getAmount());
            }
        }
    }

    // Attempt to clear off big items from affected players
    @EventHandler(priority = EventPriority.LOW)
    private void onJoin(PlayerJoinEvent event) {
        sanitizeInventory(event.getPlayer().getInventory());
    }

    @EventHandler(priority = EventPriority.LOW)
    private void onLeave(PlayerQuitEvent event) {
        sanitizeInventory(event.getPlayer().getInventory());
    }

    @EventHandler(priority = EventPriority.LOW)
    private void onKick(PlayerKickEvent event) {
        sanitizeInventory(event.getPlayer().getInventory());
    }
}