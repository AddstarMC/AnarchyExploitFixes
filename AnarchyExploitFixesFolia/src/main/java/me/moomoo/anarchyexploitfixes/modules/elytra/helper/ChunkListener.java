package me.moomoo.anarchyexploitfixes.modules.elytra.helper;

import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.util.NumberConversions;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class ChunkListener extends ElytraHelper implements Listener {

    public final Set<UUID> PLAYERS_NEAR_NEW_CHUNKS;

    public ChunkListener() {
        this.PLAYERS_NEAR_NEW_CHUNKS = new HashSet<>();
    }

    @EventHandler(priority = EventPriority.LOWEST)
    private void onChunkLoad(ChunkLoadEvent event) {
        for (Player player : event.getWorld().getPlayers()) {
            if (this.getChunkDistanceSquared(event.getChunk(), player.getLocation().clone()) < NumberConversions.square(player.getViewDistance())) {
                if (event.isNewChunk()) {
                    this.PLAYERS_NEAR_NEW_CHUNKS.add(player.getUniqueId());
                } else {
                    this.PLAYERS_NEAR_NEW_CHUNKS.remove(player.getUniqueId());
                }
            }
        }
    }

    /**
     * Since the distance here is only used to see whether a chunk is loaded roughly within the player's view distance,
     * we can resort to comparing squared distances.
     * This saves cpu usage as we don't have to use {@link Math#sqrt(double)} to get the accurate distance in chunks.
     */
    private double getChunkDistanceSquared(Chunk chunk, Location location) {
        return NumberConversions.square(chunk.getX() - location.getBlockX() >> 4) + NumberConversions.square(chunk.getZ() - location.getBlockZ() >> 4);
    }
}
