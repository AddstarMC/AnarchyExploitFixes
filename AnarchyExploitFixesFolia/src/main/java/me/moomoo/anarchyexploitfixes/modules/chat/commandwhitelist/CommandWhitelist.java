package me.moomoo.anarchyexploitfixes.modules.chat.commandwhitelist;

import com.destroystokyo.paper.event.server.AsyncTabCompleteEvent;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.enums.AEFPermission;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.utils.CommandUtil;
import me.moomoo.anarchyexploitfixes.utils.LogUtil;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.player.PlayerCommandSendEvent;
import org.bukkit.event.server.TabCompleteEvent;
import org.slf4j.event.Level;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class CommandWhitelist implements AnarchyExploitFixesModule, Listener {

    /*
     *     Credits go to YouHaveTrouble (https://github.com/YouHaveTrouble/CommandWhitelist)
     *     Code was mainly only implemented into AEF by xGinko.
     */

    private final Set<String> allowedCommands, bannedSubCommands;
    private final boolean shouldUseProtocolLib, shouldLog;

    public CommandWhitelist() {
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment("chat.command-whitelist.enable", """
                        This will make it pretty much impossible to find your plugins as only the commands you specify will be able to work.\s
                        Allow bypass using permission: anarchyexploitfixes.commandwhitelistbypass""");
        this.shouldLog = config.getBoolean("chat.command-whitelist.log", false,
                "Will show logs when a command was denied.");
        this.shouldUseProtocolLib = config.getBoolean("chat.command-whitelist.use-protocollib", false,
                "Enable only if you have problems with the regular commandwhitelist. Otherwise not recommended to use.");
        this.allowedCommands = config.getList("chat.command-whitelist.whitelisted-commands", List.of(
                        "help", "vote", "kill", "discord", "togglechat", "toggleconnectionmsgs", "toggletells", "togglewhispering", "toggleprivatemsgs",
                        "ignore", "ignorelist", "ignorehard", "toggledeathmsg", "dmt", "worldstats", "stats", "tps", "msg", "whisper", "w", "m", "t",
                        "pm", "tell", "r", "reply", "last"
                ), "Add all commands you want your players to be able to access (without the '/'). Not case sensitive.")
                .stream()
                .map(String::toLowerCase)
                .collect(Collectors.toCollection(HashSet::new));
        bannedSubCommands = new HashSet<>(config.getList("chat.command-whitelist.blacklisted-subcommands", List.of(
                "help about", "vote List", "vote Best", "vote Total", "worldstats reload", "stats reload"
        )));
    }

    @Override
    public String name() {
        return "command-whitelist";
    }

    @Override
    public String category() {
        return "chat";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        if (shouldUseProtocolLib) {
            if (AnarchyExploitFixes.getConfiguration().protocolLib_IsDisabled) {
                LogUtil.moduleLog(Level.WARN, name(), "Can't enable packet listener(s) because ProtocolLib is disabled in config.");
            } else {
                if (AnarchyExploitFixes.isProtocolLibInstalled()) {
                    new CWChatPacketListener(plugin, allowedCommands, bannedSubCommands, shouldLog).register();
                } else {
                    LogUtil.moduleLog(Level.ERROR, name(), "Can't enable packet listener(s) because ProtocolLib is missing.");
                }
            }
        }
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("chat.command-whitelist.enable", false);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    private void onCommandPreProcess(PlayerCommandPreprocessEvent event) {
        final Player player = event.getPlayer();
        if (player.hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.get())) return;

        String message = event.getMessage();
        String commandLabel = CommandUtil.getCommandLabel(message).toLowerCase();
        String fullCommand = message.substring(commandLabel.length()+1);
        fullCommand = "/"+commandLabel+fullCommand;
        event.setMessage(fullCommand);

        if (!allowedCommands.contains(commandLabel)) {
            event.setCancelled(true);
            player.sendMessage(AnarchyExploitFixes.getLang(player.locale()).chat_commandwhitelist_badcommand);
            if (shouldLog)
                AnarchyExploitFixes.getPrefixedLogger().info(player.getName() + " tried to execute a non whitelisted command: " + fullCommand);
            return;
        }

        for (String bannedSubCommand : bannedSubCommands) {
            if (message.toLowerCase().substring(1).startsWith(bannedSubCommand)) {
                event.setCancelled(true);
                player.sendMessage(AnarchyExploitFixes.getLang(player.locale()).chat_commandwhitelist_badcommand);
                if (shouldLog)
                    AnarchyExploitFixes.getPrefixedLogger().info(player.getName() + " tried to execute a blacklisted subcommand: " + message);
                return;
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGH)
    private void onInitialTabCompleteListSend(PlayerCommandSendEvent event) {
        if (event.getPlayer().hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.get())) return;

        event.getCommands().removeIf(cmd -> !allowedCommands.contains(cmd));
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onAsyncCommandTabComplete(AsyncTabCompleteEvent event) {
        if (event.getCompletions().isEmpty()) return;
        if (!(event.getSender() instanceof Player)) return;
        if (event.getSender().hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.get())) return;

        event.setCompletions(getFilteredTabCompletions(event.getBuffer(), event.getCompletions()));
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    private void onCommandTabComplete(TabCompleteEvent event) {
        if (event.getCompletions().isEmpty()) return;
        if (!(event.getSender() instanceof Player)) return;
        if (event.getSender().hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.get())) return;

        event.setCompletions(getFilteredTabCompletions(event.getBuffer(), event.getCompletions()));
    }

    private List<String> getFilteredTabCompletions(String buffer, List<String> suggestions) {
        if (buffer.startsWith("/")) buffer = buffer.substring(1);
        List<String> suggestionsList = new ArrayList<>(suggestions);
        if (suggestions.isEmpty() || bannedSubCommands.isEmpty()) return suggestionsList;
        for (String bannedSubCommand : bannedSubCommands) {
            String scommand = CommandUtil.cutLastArgument(bannedSubCommand);
            if (buffer.startsWith(scommand)) {
                String slast = CommandUtil.getLastArgument(bannedSubCommand);
                while (suggestionsList.contains(slast))
                    suggestionsList.remove(slast);
            }
        }
        return suggestionsList;
    }
}
