package me.moomoo.anarchyexploitfixes.modules.elytra.helper;

import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.utils.LocationUtil;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.HandlerList;
import org.bukkit.event.player.PlayerMoveEvent;

import java.util.UUID;

public class ElytraHelper implements AnarchyExploitFixesModule {
    private static ElytraHelper instance;
    public static final double SPEED_TOLERANCE = 0.02;

    protected final AnarchyExploitFixes plugin;
    protected final boolean calculate3D;

    private GlideListener glideListener;
    private ChunkListener chunkListener;
    private IntervalCheck intervalCheck;

    public ElytraHelper() {
        instance = this;
        this.plugin = AnarchyExploitFixes.getInstance();
        this.calculate3D = AnarchyExploitFixes.getConfiguration().elytra_calculate_3D;
    }

    public static ElytraHelper getInstance() {
        return instance;
    }

    @Override
    public String name() {
        return "elytra-helper";
    }

    @Override
    public String category() {
        return "elytra";
    }

    @Override
    public void enable() {
        glideListener = new GlideListener();
        plugin.getServer().getPluginManager().registerEvents(glideListener, plugin);
        chunkListener = new ChunkListener();
        plugin.getServer().getPluginManager().registerEvents(chunkListener, plugin);
        intervalCheck = new IntervalCheck();
        intervalCheck.startIfEnabled();
    }

    @Override
    public boolean shouldEnable() {
        Config config = AnarchyExploitFixes.getConfiguration();
        return config.elytra_enable_at_spawn || config.elytra_enable_global || config.elytra_enable_netherceiling;
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(glideListener);
        HandlerList.unregisterAll(chunkListener);
        intervalCheck.stopIfEnabled();
    }

    public Location getFrom(PlayerMoveEvent event) {
        final Location lastGlidePos = intervalCheck.LAST_GLIDE_POS.getIfPresent(event.getPlayer().getUniqueId());
        return lastGlidePos != null ? lastGlidePos : event.getFrom();
    }

    public double getBlocksPerTick(PlayerMoveEvent event) {
        double eventSpeed = calculate3D ? LocationUtil.getRelDistance3D(event.getTo(), event.getFrom()) : LocationUtil.getRelDistance2D(event.getTo(), event.getFrom());
        if (intervalCheck.isEnabled) {
            Double speedInterval = intervalCheck.PLAYER_SPEEDS.getIfPresent(event.getPlayer().getUniqueId());
            if (speedInterval != null) return Math.max(speedInterval, eventSpeed);
        }
        return eventSpeed;
    }

    public boolean isInNewChunks(UUID playerUniqueId) {
        return chunkListener.PLAYERS_NEAR_NEW_CHUNKS.contains(playerUniqueId);
    }

    public boolean isGliding(Player player) {
        return glideListener.PLAYERS_GLIDING.contains(player.getUniqueId()) || player.isGliding();
    }
}
