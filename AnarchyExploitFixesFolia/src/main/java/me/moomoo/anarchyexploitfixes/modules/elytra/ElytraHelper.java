package me.moomoo.anarchyexploitfixes.modules.elytra;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.util.Vector3d;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPlayerPosition;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPlayerPositionAndRotation;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;
import me.moomoo.anarchyexploitfixes.utils.LocationUtil;
import org.apache.commons.math3.util.FastMath;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import oshi.util.tuples.Pair;

import java.time.Duration;
import java.util.UUID;

public class ElytraHelper extends PacketListenerAbstract implements AEFModule, Listener {

    private static ElytraHelper instance;
    public static final double SPEED_TOLERANCE = 0.02;
    private final AnarchyExploitFixes plugin;
    private final boolean calculate3D;
    private final Cache<UUID, Double> speeds;
    private final Cache<UUID, Pair<Vector3d, Long>> last_player_pos;

    public ElytraHelper() {
        instance = this;
        this.plugin = AnarchyExploitFixes.getInstance();
        this.calculate3D = AnarchyExploitFixes.getConfiguration().elytra_calculate_3D;
        this.speeds = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(8)).build();
        this.last_player_pos = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(8)).build();
    }

    public static ElytraHelper getInstance() {
        return instance;
    }

    @Override
    public String name() {
        return "elytra-helper";
    }

    @Override
    public String category() {
        return "elytra";
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        if (!AnarchyExploitFixes.getConfiguration().packet_events_disabled)
            PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public boolean shouldEnable() {
        Config config = AnarchyExploitFixes.getConfiguration();
        return config.elytra_enable_at_spawn || config.elytra_enable_global || config.elytra_enable_netherceiling;
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public void onPacketReceive(PacketReceiveEvent event) {
        final Vector3d position;
        if (event.getPacketType() == PacketType.Play.Client.PLAYER_POSITION) {
            position = new WrapperPlayClientPlayerPosition(event).getPosition();
        } else if (event.getPacketType() == PacketType.Play.Client.PLAYER_POSITION_AND_ROTATION) {
            position = new WrapperPlayClientPlayerPositionAndRotation(event).getPosition();
        } else {
            return;
        }

        final UUID uuid = event.getUser().getUUID();
        final Pair<Vector3d, Long> toPos = new Pair<>(position, System.currentTimeMillis());
        final Pair<Vector3d, Long> fromPos = last_player_pos.get(uuid, k -> toPos);

        double blocksPerMilli;
        if (calculate3D) {
            blocksPerMilli = LocationUtil.getDistance3D(
                    position.x - fromPos.getA().x,
                    position.y - fromPos.getA().y,
                    position.z - fromPos.getA().z);
        } else {
            blocksPerMilli = FastMath.hypot(
                    position.x - fromPos.getA().x,
                    position.z - fromPos.getA().z);
        }

        blocksPerMilli = blocksPerMilli / FastMath.abs(toPos.getB() - fromPos.getB());

        speeds.put(uuid, blocksPerMilli * 50);
    }

    public Location getFrom(PlayerMoveEvent event) {
        return event.getFrom();
    }

    public double getBlocksPerTick(PlayerMoveEvent event) {
        return speeds.get(event.getPlayer().getUniqueId(),
                k -> calculate3D ? LocationUtil.getRelDistance3D(event.getTo(), event.getFrom()) :
                        LocationUtil.getRelDistance2D(event.getTo(), event.getFrom()));
    }

    public boolean isInNewChunks(Player player) {
        return player.getChunk().getInhabitedTime() > 200L;
    }

    public boolean isGliding(Player player) {
        return player.isGliding();
    }
}
