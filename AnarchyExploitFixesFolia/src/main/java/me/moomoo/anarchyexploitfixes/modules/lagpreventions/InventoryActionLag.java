package me.moomoo.anarchyexploitfixes.modules.lagpreventions;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.utils.LogUtil;
import org.apache.commons.math3.util.FastMath;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryAction;
import org.bukkit.event.inventory.InventoryClickEvent;

import java.time.Duration;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.logging.Level;

public class InventoryActionLag implements AnarchyExploitFixesModule, Listener {

    private final Map<InventoryAction, Integer> clickActionLimits;
    private final Cache<UUID, Map<InventoryAction, Integer>> entityInventoryClicks;
    private final Cache<Location, Map<InventoryAction, Integer>> blockInventoryClicks;
    private final boolean logIsEnabled;

    public InventoryActionLag() {
        shouldEnable();
        this.clickActionLimits = new HashMap<>();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment("lag-preventions.prevent-inventory-action-lag.enable", """
                Prevent lag generated by players quickly moving big items back and forth between inventories.\s
                Uses cached counters that auto-reset after the configurable time in milliseconds.\s
                Format is: InventoryClickAction: AllowedClicksPerTime""");
        this.logIsEnabled = config.getBoolean("lag-preventions.prevent-inventory-action-lag.log", true);
        Duration cacheTime = Duration.ofMillis(FastMath.max(config.getInt("lag-preventions.prevent-inventory-action-lag.cache-time-millis", 2000,
                "The amount of time in milliseconds an entry is kept after writing."), 1));
        this.blockInventoryClicks = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        this.entityInventoryClicks = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        Map<String, Object> defaults = new HashMap<>();
        defaults.put("COLLECT_TO_CURSOR", 5);
        defaults.put("MOVE_TO_OTHER_INVENTORY", 5);
        defaults.put("HOTBAR_SWAP", 5);
        ConfigSection section = config.getConfigSection("lag-preventions.prevent-inventory-action-lag.click-action-limits", defaults,
                "Use correct enums from: https://jd.papermc.io/paper/1.20/org/bukkit/event/inventory/InventoryAction.html.");
        for (String configuredAction : section.getKeys(false)) {
            try {
                InventoryAction action = InventoryAction.valueOf(configuredAction);
                Integer maxClicksPerTime = Integer.valueOf(section.getString(configuredAction));
                clickActionLimits.put(action, maxClicksPerTime);
            } catch (NumberFormatException e) {
                LogUtil.integerNotRecognized(Level.WARNING, name(), configuredAction);
            } catch (IllegalArgumentException e) {
                LogUtil.moduleLog(Level.WARNING, name(), "Configured InventoryClickAction '"+configuredAction+"' not recognized. " +
                        "Please use correct enums from: https://jd.papermc.io/paper/1.20/org/bukkit/event/inventory/InventoryAction.html");
            }
        }
    }

    @Override
    public String name() {
        return "prevent-inventory-action-lag";
    }

    @Override
    public String category() {
        return "lag-preventions";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("lag-preventions.prevent-inventory-action-lag.enable", false)
                && !clickActionLimits.isEmpty();
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.LOW, ignoreCancelled = true)
    private void onInventoryClick(InventoryClickEvent event) {
        if (!clickActionLimits.containsKey(event.getAction())) return;
        if (event.getInventory().getHolder() == null) return;

        if (event.getInventory().getHolder() instanceof Block block) {
            Map<InventoryAction, Integer> recordedClicks = blockInventoryClicks.getIfPresent(block.getLocation());
            if (recordedClicks == null) recordedClicks = new EnumMap<>(InventoryAction.class);
            Integer clickActionCounter = recordedClicks.get(event.getAction());
            if (clickActionCounter == null) clickActionCounter = 1;

            if (clickActionCounter > clickActionLimits.get(event.getAction())) {
                event.setCancelled(true);
                if (logIsEnabled) LogUtil.moduleLog(Level.INFO, name(),
                        "Cancelled spammy inventory click of type "+event.getAction().name()+" at" +
                                " x:" + block.getLocation().getX() + "," +
                                " y:" + block.getLocation().getY() + "," +
                                " z:" + block.getLocation().getZ() +
                                " in world: " + block.getLocation().getWorld().getName());
            }

            recordedClicks.put(event.getAction(), clickActionCounter);
            blockInventoryClicks.put(block.getLocation(), recordedClicks);

            return;
        }

        if (event.getInventory().getHolder() instanceof Entity entity) {
            Map<InventoryAction, Integer> recordedClicks = entityInventoryClicks.getIfPresent(entity.getUniqueId());
            if (recordedClicks == null) recordedClicks = new EnumMap<>(InventoryAction.class);
            Integer clickActionCounter = recordedClicks.get(event.getAction());
            if (clickActionCounter == null) clickActionCounter = 1;

            if (clickActionCounter > clickActionLimits.get(event.getAction())) {
                event.setCancelled(true);
                if (logIsEnabled) LogUtil.moduleLog(Level.INFO, name(),
                        "Cancelled spammy inventory click of type "+event.getAction().name()+" at" +
                                " x:" + entity.getLocation().getX() + "," +
                                " y:" + entity.getLocation().getY() + "," +
                                " z:" + entity.getLocation().getZ() +
                                " in world: " + entity.getLocation().getWorld().getName());
            }

            recordedClicks.put(event.getAction(), clickActionCounter);
            entityInventoryClicks.put(entity.getUniqueId(), recordedClicks);
        }
    }
}