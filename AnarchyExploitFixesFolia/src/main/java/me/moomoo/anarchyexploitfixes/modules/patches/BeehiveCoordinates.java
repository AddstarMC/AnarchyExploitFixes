package me.moomoo.anarchyexploitfixes.modules.patches;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.item.ItemStack;
import com.github.retrooper.packetevents.protocol.nbt.NBTCompound;
import com.github.retrooper.packetevents.protocol.nbt.NBTList;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSetSlot;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerWindowItems;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class BeehiveCoordinates extends PacketListenerAbstract implements AEFModule {

    private final Set<String> entityDataTagsToRemove;

    public BeehiveCoordinates() {
        super(PacketListenerPriority.HIGHEST);
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment("patches.remove-beehive-coordinates.enable",
                "Patches an exploit that allows players to obtain another player's coordinates\n" +
                        "by trading them for beehives or beenests.\n" +
                        "If the traded item contains any bees, the stored bee's NBT data could then be read from the item.\n" +
                        "This data includes, but is not limited to:\n" +
                        " - UID of the world the bee was first spawned into existence\n" +
                        " - XYZ coordinates of where the bee was first spawned into existence\n" +
                        " - XYZ coordinates of where the bee last visited a flower\n" +
                        " - XYZ coordinates of where the bee has its hive\n" +
                        " - XYZ of the bee's last coordinates before entering it's hive");
        this.entityDataTagsToRemove = new HashSet<>(config.getList("patches.remove-beehive-coordinates.tags", Arrays.asList(
                        "Pos", "HivePos", "FlowerPos", "Paper.Origin", "Paper.OriginWorld", "WorldUUIDMost", "WorldUUIDLeast"),
                "The NBT tags to filter from the item. These are the Keys that hold the position data.\n" +
                        "You may add more tags you want removed here."));
    }

    @Override
    public String name() {
        return "remove-beehive-coordinates";
    }

    @Override
    public String category() {
        return "patches";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("patches.remove-beehive-coordinates.enable", true);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() == PacketType.Play.Server.SET_SLOT) {
            WrapperPlayServerSetSlot packet = new WrapperPlayServerSetSlot(event);
            packet.setItem(filterItemStack(packet.getItem()));
            event.markForReEncode(true);
        }

        if (event.getPacketType() == PacketType.Play.Server.WINDOW_ITEMS) {
            WrapperPlayServerWindowItems packet = new WrapperPlayServerWindowItems(event);
            if (packet.getCarriedItem().isPresent()) {
                packet.setCarriedItem(filterItemStack(packet.getCarriedItem().get()));
                event.markForReEncode(true);
            }
        }
    }

    private ItemStack filterItemStack(ItemStack itemStack) {
        if (itemStack == null || itemStack.isEmpty()) return itemStack;

        final NBTCompound rootCompound = itemStack.getNBT();
        if (rootCompound == null || !rootCompound.getTags().containsKey("BlockEntityTag")) return itemStack;

        final NBTCompound blockEntityTag = rootCompound.getCompoundTagOrNull("BlockEntityTag");
        if (blockEntityTag == null || blockEntityTag.isEmpty()) return itemStack;

        rootCompound.setTag("BlockEntityTag", filterBlockEntityTag(blockEntityTag));
        itemStack.setNBT(rootCompound);
        return itemStack;
    }

    private NBTCompound filterBlockEntityTag(NBTCompound blockEntityTag) {
        if (blockEntityTag.getTags().containsKey("Bees")) {
            NBTList<NBTCompound> bees = blockEntityTag.getCompoundListTagOrNull("Bees");
            if (bees == null || bees.isEmpty()) return blockEntityTag;

            for (int i = 0; i < bees.size(); i++) {
                NBTCompound beeEntity = bees.getTag(i);
                NBTCompound beeEntityData = beeEntity.getCompoundTagOrNull("EntityData");
                if (beeEntityData != null && !beeEntityData.isEmpty()) {
                    for (String toRemove : entityDataTagsToRemove) {
                        beeEntityData.removeTag(toRemove);
                    }
                }
                beeEntity.setTag("EntityData", beeEntityData);
                bees.setTag(i, beeEntity);
            }

            blockEntityTag.setTag("Bees", bees);
        }

        if (blockEntityTag.getTags().containsKey("Items")) {
            NBTList<NBTCompound> items = blockEntityTag.getCompoundListTagOrNull("Items");
            if (items == null || items.isEmpty()) return blockEntityTag;

            for (int i = 0; i < items.size(); i++) {
                NBTCompound item = items.getTag(i);
                NBTCompound itemRootCompound = item.getCompoundTagOrNull("tag");
                if (itemRootCompound != null && itemRootCompound.getTags().containsKey("BlockEntityTag")) {
                    final NBTCompound nestedBlockEntityTag = itemRootCompound.getCompoundTagOrNull("BlockEntityTag");
                    if (nestedBlockEntityTag != null && !nestedBlockEntityTag.isEmpty()) {
                        itemRootCompound.setTag("BlockEntityTag", filterBlockEntityTag(nestedBlockEntityTag));
                    }
                }
                items.setTag(i, item);
            }

            blockEntityTag.setTag("Items", items);
        }

        return blockEntityTag;
    }
}
