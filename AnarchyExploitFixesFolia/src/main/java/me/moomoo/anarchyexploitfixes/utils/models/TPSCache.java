package me.moomoo.anarchyexploitfixes.utils.models;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.threadedregions.RegionizedServer;
import io.papermc.paper.threadedregions.ThreadedRegionizer;
import io.papermc.paper.threadedregions.TickRegionScheduler;
import io.papermc.paper.threadedregions.TickRegions;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import org.bukkit.Server;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;

public interface TPSCache {

    double getGlobalTPS();
    double getTPS();

    static @NotNull TPSCache create(long checkDelayMillis) {
        if (AnarchyExploitFixes.isServerFolia()) {
            return new Folia(checkDelayMillis);
        } else {
            return new Default(AnarchyExploitFixes.getInstance(), checkDelayMillis);
        }
    }

    final class Default implements TPSCache {

        private final Server server;
        private final Cache<Object, Double> cached_tps;
        private static final Object TPS_KEY = new Object();

        Default(JavaPlugin plugin, long checkDelayMillis) {
            this.server = plugin.getServer();
            this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
        }

        @Override
        public double getGlobalTPS() {
            Double tps = this.cached_tps.getIfPresent(TPS_KEY);
            if (tps == null) {
                tps = this.server.getTPS()[0];
                this.cached_tps.put(TPS_KEY, tps);
            }
            return tps;
        }

        @Override
        public double getTPS() {
            return getGlobalTPS();
        }
    }

    final class Folia implements TPSCache {

        private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> cached_tps;

        Folia(long checkDelayMillis) {
            this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
        }

        @Override
        public double getGlobalTPS() {
            // Get regionhandle and check if there is already a cached tps for it
            final TickRegionScheduler.RegionScheduleHandle regionHandle = RegionizedServer.getGlobalTickData();
            Double tps = this.cached_tps.getIfPresent(regionHandle);
            if (tps == null) {
                // If nothing is cached yet, get tps and add to cache
                tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
                this.cached_tps.put(regionHandle, tps);
            }
            return tps;
        }

        /**
         *   CAUTION! THIS METHOD NEEDS TO BE CALLED WITH THREAD CONTEXT
         */
        @Override
        public double getTPS() {
            // Get the potential separate region that owns the location
            final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                    currentRegion = TickRegionScheduler.getCurrentRegion();
            // If not happening on a separate region, it must mean we're on the main region
            if (currentRegion == null) {
                return getGlobalTPS();
            }
            // Get regionhandle and check if there is already a cached tps for it
            final TickRegionScheduler.RegionScheduleHandle regionHandle = currentRegion.getData().getRegionSchedulingHandle();
            Double tps = this.cached_tps.getIfPresent(regionHandle);
            if (tps == null) {
                // If nothing is cached yet, get tps and add to cache
                tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
                this.cached_tps.put(regionHandle, tps);
            }
            return tps;
        }
    }
}