package me.moomoo.anarchyexploitfixes.utils;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.util.concurrent.AtomicDouble;
import io.papermc.paper.threadedregions.RegionizedServer;
import io.papermc.paper.threadedregions.ThreadedRegionizer;
import io.papermc.paper.threadedregions.TickRegionScheduler;
import io.papermc.paper.threadedregions.TickRegions;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import org.bukkit.Location;
import org.bukkit.Server;
import org.bukkit.World;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;

public interface TPSCache {

    double getGlobalTPS();
    double getTPS(Location location);
    double getTPS(World world, int chunkX, int chunkZ);

    static @NotNull TPSCache create(long checkDelayMillis) {
        if (AnarchyExploitFixes.isServerFolia()) {
            return new Folia(AnarchyExploitFixes.getInstance(), checkDelayMillis);
        } else {
            return new Default(AnarchyExploitFixes.getInstance(), checkDelayMillis);
        }
    }

    final class Default implements TPSCache {

        private final Server server;
        private final Cache<Boolean, Double> cached_tps;

        Default(JavaPlugin plugin, long checkDelayMillis) {
            this.server = plugin.getServer();
            this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
        }

        @Override
        public double getGlobalTPS() {
            Double tps = this.cached_tps.getIfPresent(true);
            if (tps == null) {
                tps = this.server.getTPS()[0];
                this.cached_tps.put(true, tps);
            }
            return tps;
        }

        @Override
        public double getTPS(World world, int chunkX, int chunkZ) {
            return getGlobalTPS();
        }

        @Override
        public double getTPS(Location location) {
            return getGlobalTPS();
        }
    }

    final class Folia implements TPSCache {

        private final JavaPlugin plugin;
        private final Server server;
        private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> cached_tps;

        Folia(JavaPlugin plugin, long checkDelayMillis) {
            this.plugin = plugin;
            this.server = plugin.getServer();
            this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
        }

        @Override
        public double getGlobalTPS() {
            final TickRegionScheduler.RegionScheduleHandle regionHandle = RegionizedServer.getGlobalTickData();
            Double tps = this.cached_tps.getIfPresent(regionHandle);
            if (tps == null) {
                tps = regionHandle.getTickReport15s(System.nanoTime()).tpsData().segmentAll().average();
                this.cached_tps.put(regionHandle, tps);
            }
            return tps;
        }

        @Override
        public double getTPS(Location location) {
            return getTPS(location.getWorld(), location.getBlockX() >> 4, location.getBlockZ() >> 4);
        }

        @Override
        public double getTPS(World world, int chunkX, int chunkZ) {
            AtomicDouble atomic_tps = new AtomicDouble();
            this.server.getRegionScheduler().execute(plugin, world, chunkX, chunkZ, () -> {
                final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                        currentRegion = TickRegionScheduler.getCurrentRegion();
                if (currentRegion == null) {
                    atomic_tps.set(getGlobalTPS());
                    return;
                }
                final TickRegionScheduler.RegionScheduleHandle regionHandle = currentRegion.getData().getRegionSchedulingHandle();
                Double tps = this.cached_tps.getIfPresent(regionHandle);
                if (tps == null) {
                    tps = regionHandle.getTickReport15s(System.nanoTime()).tpsData().segmentAll().average();
                    this.cached_tps.put(regionHandle, tps);
                }
                atomic_tps.set(tps);
            });

            return atomic_tps.get();
        }
    }
}