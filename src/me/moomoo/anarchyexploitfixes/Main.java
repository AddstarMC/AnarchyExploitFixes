// This code has one main class for a reason. It is easier to find backdoors by scrolling instead of going through 50000 classes. (Example, L2X9core had some code hidden with a backdoor, but no one found it even when it was opensource due to 50000 classes)
// Simply scroll to the bottom.
package me.moomoo.anarchyexploitfixes;

import io.netty.channel.*;
import net.minecraft.server.v1_12_R1.PacketPlayInFlying;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.Container;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.craftbukkit.v1_12_R1.entity.CraftPlayer;
import org.bukkit.entity.*;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockDamageEvent;
import org.bukkit.event.block.BlockPhysicsEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.block.BlockRedstoneEvent;
import org.bukkit.event.entity.*;
import org.bukkit.event.inventory.*;
import org.bukkit.event.player.*;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;

import java.awt.*;
import java.time.Instant;
import java.util.HashMap;
import java.util.HashSet;

public class Main extends JavaPlugin implements Listener {
    FileConfiguration config = getConfig();
    public static HashMap<Player, Integer> newchunks = new HashMap<>();
    public static HashMap<Player, Integer> oldchunks = new HashMap<>();
    public static final Integer[] old_total = {0};
    public static final Integer[] new_total = {0};
    @Override
    public void onEnable() {
        if(getConfig().getBoolean("BoatflyPatchStrict")){
            if(getConfig().getBoolean("PreventGodMode")){
                for (Player p:Bukkit.getOnlinePlayers()){
                    removePlayer(p);
                    injectPlayer(p);
                    a.put(p, 0);
                    b.put(p, 0);
                }
            }
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> {
                if(e.isInsideVehicle()){
                    int x = e.getLocation().getBlockX();
                    int y = e.getLocation().getBlockY();
                    int z = e.getLocation().getBlockZ();
                    // ik its a mess idgaf
                    if((e.getWorld().getBlockAt(x, y-1, z).getType() == Material.AIR) && e.getWorld().getBlockAt(x, y-2, z).getType() == Material.AIR && e.getWorld().getBlockAt(x, y-3, z).getType() == Material.AIR){
                        if(e.getVehicle() instanceof Boat){
                            e.getVehicle().remove();
                            if(getConfig().getBoolean("BoatflyMessage")){
                                e.sendMessage(ChatColor.GOLD + "Boatfly disabled due to an exploit >:) If you aren't boat flying, boats on land are a little buggy.");
                            }
                        }
                    }
                }
            })), 0L, getConfig().getInt("BoatflyPatchStrictCheckRate"));
        }
        if(getConfig().getBoolean("StrictIllegalPrevention")){
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> e.getInventory().forEach(bb -> {
                if(bb != null){
                    if(bb.getAmount() > bb.getMaxStackSize()){
                        bb.setAmount(bb.getMaxStackSize());
                    }
                }
            }))), 0L, 20L);
        }
        Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> {
            if(newchunks.get(e) != null){
                if(!e.isOp()){
                    if(newchunks.get(e) > 60){
                        broadcastOp(ChatColor.RED + e.getName() + " is generating a lot of chunks per second! (" + newchunks.get(e) + ")");
                    }
                }
            }
        })), 0L, 20L);
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            new_total[0] = 0;
            old_total[0] = 0;
            Bukkit.getOnlinePlayers().forEach(b -> {
                if(newchunks.get(b) != null){
                    new_total[0] = new_total[0] + newchunks.get(b);
                }
            });
            Bukkit.getOnlinePlayers().forEach(b -> {
                if(oldchunks.get(b) != null){
                    old_total[0] = old_total[0] + oldchunks.get(b);
                }
            });
        }, 0L, 20L);
        saveDefaultConfig();
        System.out.println("[ENABLED] AnarchyExploitFixes - Made by moomoo");
        Bukkit.getServer().getPluginManager().registerEvents(this, this);
        int pluginId = 8700; // <-- Replace with the id of your plugin!
        Metrics metrics = new Metrics(this, pluginId);
        if(Bukkit.getPluginManager().getPlugin("PlaceholderAPI") != null){
            new Expansions(this).register();
        }
    }
    public void onDisable() {
        System.out.println("[DISABLED] AnarchyExploitFixes - Made by moomoo");
    }
    @EventHandler
    public void onElytra(EntityToggleGlideEvent evt) {
        if(getConfig().getBoolean("DisableAllElytras")){
            evt.setCancelled(true);
            evt.getEntity().sendMessage("Elytras currently disabled due to LAG exploit.");
        }
    }
    @EventHandler
    public void onProjectileLaunch(ProjectileLaunchEvent evt) {
        String entity = evt.getEntity().toString(); // The entity
        if(getConfig().getBoolean("DisableWithers")){
            if(entity.equals("CraftWitherSkull")){
                evt.setCancelled(true);
            }
        }
    }

    @EventHandler
    private void onPlayerBucketEvent(PlayerBucketEmptyEvent evt) {
        if(getConfig().getBoolean("PreventDestroyingEndPortals")){
            String playerName = evt.getPlayer().getName();
            String type = evt.getBlockClicked().getType().toString();
            String face = evt.getBlockFace().toString();
            String world = evt.getBlockClicked().getWorld().getName();
            if(getConfig().getBoolean("DEBUG")){
                System.out.println("PlayerBucketEmptyEvent " + face + " " + type);
            }
            if (type == "BEDROCK") {
                if (world.equalsIgnoreCase("world_the_end")) {
                    if (face == "NORTH" || face == "EAST" || face == "SOUTH" || face == "WEST") {
                        evt.setCancelled(true);
                        System.out.println("Prevented " + playerName + " from destroying a portal!");
                    }
                }
            }
            if (type == "ENDER_PORTAL_FRAME") {
                if (face == "NORTH" || face == "EAST" || face == "SOUTH" || face == "WEST") {
                    evt.setCancelled(true);
                    System.out.println("Prevented " + playerName + " from destroying a portal!");
                }
            }
            if(face == "UP" || face == "DOWN"){
                if(evt.getPlayer().getWorld().getBlockAt(evt.getBlockClicked().getX(), evt.getBlockClicked().getY() -1, evt.getBlockClicked().getZ()).getType().toString() == "ENDER_PORTAL" || evt.getPlayer().getWorld().getBlockAt(evt.getBlockClicked().getX(), evt.getBlockClicked().getY() +1, evt.getBlockClicked().getZ()).getType().toString() == "ENDER_PORTAL") {
                    evt.setCancelled(true);
                    System.out.println("Prevented " + playerName + " from destroying a portal!");
                }
            }
        }
    }
    @EventHandler
    private void onEntityPortalEvent(EntityPortalEvent evt) {
        if(getConfig().getBoolean("PreventDonkeysFromGoingThroughPortals")){
            Entity entity = evt.getEntity();
            if(getConfig().getBoolean("DEBUG")){
                System.out.println("EntityPortalEvent  " + entity);
            }
            if(entity instanceof ChestedHorse){
                if(((ChestedHorse) entity).isCarryingChest()){
                    evt.setCancelled(true);
                    if(!getConfig().getBoolean("NoConsoleOutput")){
                        System.out.println("Prevented a " + entity.toString() + " from going through portal");
                    }
                }
            }
        }
    }
//    @EventHandler
//    private void onLightUpdate(Light)
//    private HashSet<String> blockplace = new HashSet<String>();
//    @EventHandler
//    private void onBlockBreak(BlockPlaceEvent evt){
//        if(getConfig().getBoolean("LightLagFix")){
//            if(evt.getBlock().getWorld().getBlockAt(evt.getBlock().getX(), evt.getBlock().getY() -1, evt.getBlock().getZ()).getType() == Material.AIR){
//                if(blockplace.contains(String.valueOf(evt.getBlock().getX() + evt.getBlock().getY() + evt.getBlock().getZ()))){
//                    evt.setCancelled(true);
//                    evt.getPlayer().sendMessage("Please wait a bit!");
//                } else {
//                    System.out.println(evt.getBlock().getWorld().getBlockAt(evt.getBlock().getX(), evt.getBlock().getY() -1, evt.getBlock().getZ()));
//                    blockplace.add(String.valueOf(evt.getBlock().getX() + evt.getBlock().getY() + evt.getBlock().getZ()));
//                }
//            }
//
//        }
//    }
    @EventHandler
    private void onPlayerInteractEvent(PlayerInteractEvent evt){
            if(getConfig().getBoolean("RemoveIllegalBlocksOnInteract")){
                if (evt.getClickedBlock() != null) {
                    if (evt.getClickedBlock().getState() instanceof Container) {
                        if(getConfig().getBoolean("DEBUG")){
                            System.out.println("PlayerInteractEvent " + evt.getClickedBlock().getType().toString());
                        }
                        getConfig().getList("BANNED_BLOCKS").forEach(b -> {
                            ((Container) evt.getClickedBlock().getState()).getInventory().remove(Material.getMaterial((String) b));
                        });
                    }
                }
            }
    }
    @EventHandler
    private void onPlayerJoinEvent(PlayerJoinEvent evt){
        System.out.println("Player " + evt.getPlayer().getName() + " language = " + evt.getPlayer().getLocale());
            if(getConfig().getBoolean("RemoveIllegalBlocksOnJoin")){
                getConfig().getList("BANNED_BLOCKS").forEach(b -> {
                    if(getConfig().getBoolean("DEBUG")){
                        System.out.println("PlayerJoinEvent");
                    }
                    evt.getPlayer().getInventory().remove(Material.getMaterial((String) b));
                });
            }
            if(getConfig().getBoolean("GrayJoinLeaveMessages")){
                evt.setJoinMessage("§7" + evt.getPlayer().getName() + " " + getConfig().getString("JoinMessage"));
            }
            if(getConfig().getBoolean("RevertStackedItems")){
                evt.getPlayer().getInventory().forEach(b -> {
                    if(b != null){
                        if(b.getAmount() > b.getMaxStackSize()){
                            b.setAmount(b.getMaxStackSize());
                        }
                    }
                });
            }
    }
    @EventHandler
    private void onPlayerLeave(PlayerQuitEvent evt){
        if(getConfig().getBoolean("GrayJoinLeaveMessages")){
            evt.setQuitMessage("§7" + evt.getPlayer().getName() + " " + getConfig().getString("LeaveMessage"));
        }
    }
    @EventHandler
    private void onInventoryOpenEvent(InventoryOpenEvent evt){
        if(getConfig().getBoolean("RemoveIllegalBlocksOnInventoryOpen")) {
            getConfig().getList("BANNED_BLOCKS").forEach(b -> {
                if(getConfig().getBoolean("DEBUG")){
                    System.out.println("InventoryOpenEvent");
                }
                evt.getPlayer().getInventory().remove(Material.getMaterial((String) b));
            });
        }
        if(getConfig().getBoolean("RevertStackedItems")){
            evt.getPlayer().getInventory().forEach(b -> {
                if(b != null){
                    if(b.getAmount() > b.getMaxStackSize()){
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }
    @EventHandler
    private void onBlockDropItemEvent(PlayerDropItemEvent evt){
        if(getConfig().getBoolean("DEBUG")){
            System.out.println("§6DEBUG: " + evt.getItemDrop().getItemStack().getType().toString());
        }
        if(getConfig().getBoolean("RemoveIllegalBlocksOnDrop")) {
            if(getConfig().getBoolean("DEBUG")){
                System.out.println("PlayerDropItemEvent");
            }
            String item = evt.getItemDrop().getItemStack().getType().toString();
            if (getConfig().getList("BANNED_BLOCKS").contains(item)) {
                evt.getItemDrop().getItemStack().setType(Material.getMaterial(getConfig().getString("Replacement_Item")));
                evt.getPlayer().getInventory().remove(Material.BEDROCK);
                evt.setCancelled(true);
            }
        }
        if(getConfig().getBoolean("RevertStackedItems")){
            evt.getPlayer().getInventory().forEach(b -> {
                if(b != null){
                    if(b.getAmount() > b.getMaxStackSize()){
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }
    @EventHandler
    public void onTeleport(PlayerTeleportEvent evt){
        if(getConfig().getBoolean("PreventNetherRoof")){
            if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                if(!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")) {
                    if (evt.getFrom().getY() < 128 && evt.getTo().getY() >= 128) {
                        evt.getPlayer().teleport(evt.getFrom());
                    }
                }
            }
        }
    }
    public HashSet<String> playersinnewchunks = new HashSet<String>();
    @EventHandler
    public void PlayerMove(PlayerMoveEvent evt){
        if(getConfig().getBoolean("PreventNetherRoof")){
            if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                if(!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")) {
                    if (evt.getTo().getY() >= 128) {
                        evt.getPlayer().teleport(new Location(evt.getPlayer().getWorld(), evt.getPlayer().getLocation().getX(), 120, evt.getPlayer().getLocation().getZ()));
                        evt.getPlayer().performCommand("vote");
                    }
                }
            }
            if(evt.getPlayer().isInsideVehicle()){
                if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")){
                    if(!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")){
                        if(evt.getPlayer().getLocation().getY() > 127){
                            evt.getPlayer().leaveVehicle();
                            evt.getPlayer().performCommand("vote");
                        }
                    }
                }
            }
            if(evt.getPlayer().isGliding()){
                if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")){
                    if(!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")){
                        if(evt.getPlayer().getLocation().getY() > 127){
                            evt.getPlayer().setGliding(false);
                            evt.getPlayer().performCommand("vote");
                        }
                    }
                }
            }
        }

        if(evt.getPlayer().isGliding()){
            Location from = evt.getFrom();
            Location to = evt.getTo();
            double distX = to.getX() - from.getX();
            double distZ = to.getZ() - from.getZ();
            double finalValue = Math.hypot(distX, distZ);
            double tps = Bukkit.getServer().getTPS()[0];
            if(tps < getConfig().getDouble("Elytra")){
                Player player = evt.getPlayer();
                PlayerInventory i = player.getInventory();
                Location l = i.getLocation();
                if(evt.getPlayer().getLocale().startsWith("es")){
                    evt.getPlayer().sendActionBar(ChatColor.DARK_RED + "Los Elytras están actualmente deshabilitados porque el tps es mas bajo que " + getConfig().getInt("Elytra"));
                } else {
                    evt.getPlayer().sendActionBar(ChatColor.DARK_RED + "Elytras are currently disabled because the tps is lower than " + getConfig().getInt("Elytra"));
                }
                evt.setCancelled(true);
                if(getConfig().getBoolean("RemoveElytra")){
                    evt.getPlayer().setGliding(false);
                    if (i.getChestplate() != null && i.getChestplate().getType().equals(Material.ELYTRA)) {
                        ItemStack elytra = i.getChestplate();
                        i.setChestplate(null);
                        l.getWorld().dropItemNaturally(l, elytra);
                    }
                }
            } else {
                if(playersinnewchunks.contains(evt.getPlayer().getName())){
                    if(evt.getPlayer().getLocation().getY() > 127 && evt.getPlayer().getWorld().getName() == "world_nether"){
                    if(finalValue > 0.5) {
                        if (getConfig().getBoolean("PreventNetherRoof")) {
                            evt.setCancelled(true);
                            if(evt.getPlayer().getLocale().startsWith("es")){
                                evt.getPlayer().sendMessage("Solo puedes ir en chunks viejos en el techo. Desequipa tus élitros para dejar de volar.");
                            } else{
                                evt.getPlayer().sendMessage("You can only go in old chunks on the roof. Unequip your elytra to stop flying.");
                            }
                        }
                    }
                    } else {
                        if(finalValue > (getConfig().getDouble("ElytraNewChunkSpeed") + 0.02) && !evt.getPlayer().isOp()){
                            evt.setCancelled(true);
                            if(evt.getPlayer().getLocale().startsWith("es")){
                                evt.getPlayer().sendActionBar(ChatColor.RED + "Baja la configuración de tu élitro, la velocidad está restringida en nuevos chunks.");
                            } else {
                                evt.getPlayer().sendActionBar(ChatColor.RED + "Turn down your elytra settings, speed is restricted in new chunks.");
                            }
                            evt.getPlayer().playSound(evt.getPlayer().getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0F, 1.0F);
                            if(getConfig().getBoolean("SendClientInstructions")){
                                if(evt.getPlayer().getLocale() != "es"){
                                    evt.getPlayer().sendMessage(" ");
                                    evt.getPlayer().sendMessage(ChatColor.GRAY + "Change your elytra hack settings to this");
                                    evt.getPlayer().sendMessage(" ");
                                    evt.getPlayer().sendMessage(ChatColor.RED + "Future settings: Speed " + Math.round((getConfig().getDouble("ElytraNewChunkSpeed") * 10) * 100.0) / 100.0);
                                    evt.getPlayer().sendMessage(ChatColor.BLUE + "KAMI BLUE settings: Speed " + Math.round(getConfig().getDouble("ElytraNewChunkSpeed") * 100.0) / 100.0);
                                    evt.getPlayer().sendMessage(" ");
                                }
                            }
                        } else {
                            if(getConfig().getBoolean("ElytraActionBar")){
                                if(evt.getPlayer().getLocale().startsWith("es")){
                                    evt.getPlayer().sendActionBar(ChatColor.GRAY + "Estás volando en" + ChatColor.DARK_RED + " NUEVO" + ChatColor.GRAY + " chunks. Velocidad: " + (String.format("%.2f", Math.min((double)Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY + getConfig().getDouble("ElytraNewChunkSpeed")));
                                } else {
                                    evt.getPlayer().sendActionBar(ChatColor.GRAY + "You are flying in" + ChatColor.DARK_RED + " NEW" + ChatColor.GRAY + " chunks. Speed: " + (String.format("%.2f", Math.min((double)Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY + getConfig().getDouble("ElytraNewChunkSpeed")));
                                }
                            }
                        }
                    }
                } else {
                    if(finalValue > (getConfig().getDouble("ElytraOldChunkSpeed") + 0.02)){
                        evt.setCancelled(true);
                        evt.getPlayer().sendActionBar(ChatColor.RED + "Turn down your elytra settings, you are going WAY too fast.");
                        evt.getPlayer().playSound(evt.getPlayer().getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0F, 1.0F);
                        if(getConfig().getBoolean("SendClientInstructions")){
                            evt.getPlayer().sendMessage(" ");
                            evt.getPlayer().sendMessage(ChatColor.GRAY + "Change your elytra hack settings to this");
                            evt.getPlayer().sendMessage(" ");
                            evt.getPlayer().sendMessage(ChatColor.RED + "Future settings: Speed " + Math.round((getConfig().getDouble("ElytraOldChunkSpeed") * 10) * 100.0) / 100.0);
                            evt.getPlayer().sendMessage(ChatColor.BLUE + "KAMI BLUE settings: Speed " +  Math.round(getConfig().getDouble("ElytraOldChunkSpeed") * 100.0) / 100.0);
                            evt.getPlayer().sendMessage(" ");
                        }
                    } else {
                        if(getConfig().getBoolean("ElytraActionBar")){
                            if(evt.getPlayer().getLocale().startsWith("es")){
                                evt.getPlayer().sendActionBar(ChatColor.GRAY + "Estás volando en" + ChatColor.GREEN + " ANTIGUO" + ChatColor.GRAY + " chunks. Velocidad: " + (String.format("%.2f", Math.min((double)Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY +  getConfig().getDouble("ElytraOldChunkSpeed")));
                            } else {
                                evt.getPlayer().sendActionBar(ChatColor.GRAY + "You are flying in" + ChatColor.GREEN + " OLD" + ChatColor.GRAY + " chunks. Speed: " + (String.format("%.2f", Math.min((double)Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY +  getConfig().getDouble("ElytraOldChunkSpeed")));
                            }
                        }
                    }
                }

            }
        }
    }
    @EventHandler
    public void onChunkLoad(ChunkLoadEvent evt){
        if(evt.isNewChunk()){
            for (Player p:Bukkit.getOnlinePlayers()){
                Point p1 = new Point(evt.getChunk().getX(), evt.getChunk().getZ());
                Point p2 = new Point(p.getLocation().getChunk().getX(), p.getLocation().getChunk().getZ());
                if (p1.distance(p2) < 100) {
                    playersinnewchunks.add(p.getName());
                    if(getConfig().getBoolean("ChunksCommand")){
                        newchunks.merge(p, 1, Integer::sum);
                        Bukkit.getScheduler().runTaskLater(this, () -> {
                            newchunks.merge(p, -1, Integer::sum);
                        }, 20L);
                    }
                }
            }
        } else {
            for (Player p:Bukkit.getOnlinePlayers()){
                Point p1 = new Point(evt.getChunk().getX(), evt.getChunk().getZ());
                Point p2 = new Point(p.getLocation().getChunk().getX(), p.getLocation().getChunk().getZ());
                if (p1.distance(p2) < 100) {
                    playersinnewchunks.remove(p.getName());
                    if(getConfig().getBoolean("ChunksCommand")){
                        oldchunks.merge(p, 1, Integer::sum);
                        Bukkit.getScheduler().runTaskLater(this, () -> {
                            oldchunks.merge(p, -1, Integer::sum);
                        }, 20L);
                    }
                }
            }
        }
        if(getConfig().getBoolean("RemoveSkullsOnChunkLoad")){
            for(Entity e : evt.getChunk().getEntities()){
                if(e.getType() == EntityType.WITHER_SKULL){
                    e.remove();
                }
            }
        }
    }
    @EventHandler
    public void onKick(PlayerKickEvent event) {
        if (event.getReason().equalsIgnoreCase("Kicked for spamming")) {
            if(getConfig().getBoolean("PreventSpamKick")){
                event.setCancelled(true);
            } else {
                if(getConfig().getBoolean("MaskKickMessages")){
                    if(event.getPlayer().getLocale().startsWith("es")){
                        event.setReason(ChatColor.GRAY + "Ha perdido la conexión con el servidor");
                    } else {
                        event.setReason(ChatColor.GRAY + "You have lost connection to the server");
                    }
                }
            }
        } else {
            if(getConfig().getBoolean("MaskKickMessages")){
                if(event.getPlayer().getLocale().startsWith("es")){
                    event.setReason(ChatColor.GRAY + "Ha perdido la conexión con el servidor");
                } else {
                    event.setReason(ChatColor.GRAY + "You have lost connection to the server");
                }
            }
        }
    }
    @EventHandler
    private void onBlockDamage(BlockDamageEvent evt){
        if(getConfig().getBoolean("DEBUG")){
            System.out.println("BlockDamageEvent " + evt.getBlock().getType().toString());
        }
        if(getConfig().getBoolean("AllowBreakingBedrock")){
            if(evt.getBlock().getType().toString() == "BEDROCK"){
                if(evt.getBlock().getWorld().getName().equalsIgnoreCase("world_nether")){
                    if(evt.getBlock().getY() > 6 && evt.getBlock().getY() < 123){
                        evt.getBlock().setType(Material.AIR);
                    }
                }
                if(evt.getBlock().getWorld().getName().equalsIgnoreCase("world")){
                    if(evt.getBlock().getY() > 6){
                        evt.getBlock().setType(Material.AIR);
                    }
                }

            }
        }
    }
    @EventHandler
    private void onChunkLoadEvent(ChunkLoadEvent evt) {
        if(getConfig().getBoolean("RemoveALLIllegalBlocksOnCHUNKLOAD")){
            Chunk c = evt.getChunk();
            if(!evt.isNewChunk()){
                if(!c.getWorld().getName().equalsIgnoreCase("world_the_end")){
                    int cx = c.getX() << 4;
                    int cz = c.getZ() << 4;
                    for (int x = cx; x < cx + 16; x++) {
                        for (int z = cz; z < cz + 16; z++) {
                            for (int y = 0; y < 128; y++) {

                                if ((getConfig().getList("BANNED_BLOCKS").contains(c.getBlock(x, y, z).getType().toString()))) {
                                    if(y > 5){
                                        if(evt.getChunk().getWorld().getName().equalsIgnoreCase("world_nether")){
                                            if(y < 123){
                                                c.getBlock(x, y, z).setType(Material.AIR);
                                                //System.out.println("Found bedrock at " + x + " " + y + " " + z);
                                            }
                                        }
                                        if(evt.getChunk().getWorld().getName().equalsIgnoreCase("world")){
                                            c.getBlock(x, y, z).setType(Material.AIR);
                                            //System.out.println("Found bedrock at " + x + " " + y + " " + z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if(getConfig().getBoolean("FillInBedrockFloor")){
            Chunk c = evt.getChunk();
            if(!evt.isNewChunk()){
                if(!c.getWorld().getName().equalsIgnoreCase("world_the_end")){
                    int cx = c.getX() << 4;
                    int cz = c.getZ() << 4;
                    for (int x = cx; x < cx + 16; x++) {
                        for (int z = cz; z < cz + 16; z++) {
                            for (int y = 0; y < 128; y++) {
                                    if(y == 0){
                                        if(c.getBlock(x,y,z).getType() != Material.BEDROCK){
                                            c.getBlock(x,y,z).setType(Material.BEDROCK);
                                        }
                                    }
                            }
                        }
                    }
                }
            }
        }
        if(getConfig().getBoolean("FillInBedrockRoof")){
            Chunk c = evt.getChunk();
            if(!evt.isNewChunk()){
                if(c.getWorld().getName().equalsIgnoreCase("world_nether")){
                    int cx = c.getX() << 4;
                    int cz = c.getZ() << 4;
                    for (int x = cx; x < cx + 16; x++) {
                        for (int z = cz; z < cz + 16; z++) {
                            for (int y = 0; y < 128; y++) {
                                if(y == 127){
                                    if(c.getBlock(x,y,z).getType() != Material.BEDROCK){
                                        c.getBlock(x,y,z).setType(Material.BEDROCK);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    long lastGathered;
    @EventHandler
    public void onRedstoneEvent(BlockRedstoneEvent evt) {
        long now = Instant.now().toEpochMilli();
        double tps = Bukkit.getServer().getTPS()[0];
        if(tps < getConfig().getDouble("Redstone")){
            int current = evt.getOldCurrent();
            evt.setNewCurrent(current);
            if ((now - lastGathered) >= 30000) {
                lastGathered = now;
                System.out.println("Disabled all redstone because tps is " + tps);
            }
        } else {
            int newcurrent = evt.getNewCurrent();
            evt.setNewCurrent(newcurrent);
            System.out.println("Redstone at " + evt.getBlock().getLocation());
        }
    }
    @EventHandler
    private void onExplode(EntityExplodeEvent evt){
        double tps = Bukkit.getServer().getTPS()[0];
        if(tps < getConfig().getDouble("Explosions")){
            evt.setCancelled(true);
        }
        if(getConfig().getBoolean("DisableExplosions")) {
            evt.setCancelled(true);
        }
    }
    @EventHandler
    private void onExplodePrime(ExplosionPrimeEvent evt){
        if(getConfig().getBoolean("DisableExplosions")){
            evt.setCancelled(true);
        }
    }
    @EventHandler
    private void onMove(PlayerMoveEvent evt){
        if(getConfig().getBoolean("BoatflyPatch")){
            if(evt.getPlayer().isInsideVehicle()){
                Integer x = evt.getPlayer().getLocation().getBlockX();
                Integer y = evt.getPlayer().getLocation().getBlockY();
                Integer z = evt.getPlayer().getLocation().getBlockZ();

                Location from = evt.getFrom();
                Location to = evt.getTo();
                double distY = to.getY() - from.getY();

                double distX = to.getX() - from.getX();
                double distZ = to.getZ() - from.getZ();
                double finalValue = Math.hypot(distX, distZ);

                // ik its a mess idgaf
                if((evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType() == Material.AIR) && evt.getPlayer().getWorld().getBlockAt(x, y-2, z).getType() == Material.AIR && evt.getPlayer().getWorld().getBlockAt(x, y-3, z).getType() == Material.AIR){
                    if(distY != -0.439999999105936){
                        if(evt.getPlayer().getVehicle() instanceof Boat){
                                if(finalValue > 0.50 || distY > 0.0){
                                    evt.getPlayer().getVehicle().remove();
                                    if(getConfig().getBoolean("BoatflyMessage")){
                                        if(evt.getPlayer().getLocale().startsWith("es")){
                                            evt.getPlayer().sendMessage(ChatColor.GOLD + "Bote volar Deshabilitado debido a un exploit >:)");
                                        } else {
                                            evt.getPlayer().sendMessage(ChatColor.GOLD + "Boatfly disabled due to an exploit >:) If you aren't boat flying, boats on land are a little buggy.");
                                        }
                                    }
                                }
                        }
                    }
                }
            }
        }
        if(getConfig().getBoolean("DisableAllElytras")) {
            Player player = evt.getPlayer();
            PlayerInventory i = player.getInventory();
            Location l = i.getLocation();
            if (i.getChestplate() != null && i.getChestplate().getType().equals(Material.ELYTRA)) {
                ItemStack elytra = i.getChestplate();
                i.setChestplate(null);
                l.getWorld().dropItemNaturally(l, elytra);
                if(evt.getPlayer().getLocale().startsWith("es")){
                    evt.getPlayer().sendMessage("Elytras desactivado debido a la explotación de LAG.");
                } else {
                    evt.getPlayer().sendMessage("Elytras disabled due to LAG exploit.");
                }
            }
        }
        double tps_double = Bukkit.getServer().getTPS()[0];
        if(getConfig().getBoolean("PreventGoingBelowBedrockFloorOnElytra") || getConfig().getBoolean("PreventGoingBelowBedrockFloor")){
                if(evt.getPlayer().getLocation().getY() < 0){
                    if(!evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_the_end")){
                        evt.getPlayer().getWorld().getBlockAt(evt.getPlayer().getLocation().getBlockX(), 0, evt.getPlayer().getLocation().getBlockZ()).setType(Material.BEDROCK);
                        evt.setTo(evt.getFrom().add(0, 2, 0));
                    }
                }
        }
    }
    // dupes for 1b1t
    @EventHandler
    private void onPunch(EntityDamageByEntityEvent evt){
        if(getConfig().getBoolean("SlowDupe")) {
            if (evt.getEntityType() == EntityType.ITEM_FRAME) {
                double d = Math.random();
                // instanceof ShulkerBox wasnt working :/
                if ((((ItemFrame) evt.getEntity()).getItem().getType().toString().contains("SHULKER_BOX"))) {
                    if((d * 10) > 9.99) {
                        evt.getEntity().getWorld().dropItemNaturally(evt.getEntity().getLocation(), ((ItemFrame) evt.getEntity()).getItem());
                        System.out.println(evt.getDamager().getName() + " duped item");
                    }
                } else {
                    if (d > 0.99 && (d * 10) < 9.99) {
                        evt.getEntity().getWorld().dropItemNaturally(evt.getEntity().getLocation(), ((ItemFrame) evt.getEntity()).getItem());
                        System.out.println(evt.getDamager().getName() + " duped item");
                    } else if((d * 10) > 9.99){
                        evt.getEntity().getWorld().dropItemNaturally(evt.getEntity().getLocation(), ((ItemFrame) evt.getEntity()).getItem().asQuantity(((ItemFrame) evt.getEntity()).getItem().getMaxStackSize()));
                        System.out.println(evt.getDamager().getName() + " duped item");
                    }
                }
            }
        }
    }
    @EventHandler
    private void onInventoryInteractEvent(InventoryInteractEvent evt){
        if(getConfig().getBoolean("DEBUG")){
            System.out.println("InventoryInteractEvent ");
        }
        if(getConfig().getBoolean("RemoveIllegalBlocksOnInteract")){
            ItemStack[] item = evt.getInventory().getContents();
//            evt.getInventory().getContents().for(b -> {
//                if(b)
//            });
            getConfig().getList("BANNED_BLOCKS").forEach(b -> {
                if(evt.getInventory().contains(Material.getMaterial((String) b))){
                    evt.getInventory().remove(Material.getMaterial((String) b));
                    evt.setCancelled(true);
                }
            });
        }
        if(getConfig().getBoolean("RevertStackedItems")){
            evt.getInventory().forEach(b -> {
                if(b != null){
                    if(b.getAmount() > b.getMaxStackSize()){
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }
    @EventHandler
    private void onInventoryClick(InventoryClickEvent evt){
        if(getConfig().getBoolean("RemoveIllegalBlocksOnClick")){
            if(evt.getCurrentItem() != null){
                String item = evt.getCurrentItem().getType().toString();

                if (getConfig().getList("BANNED_BLOCKS").contains(item)) {
                    if(getConfig().getBoolean("DEBUG")){
                        System.out.println("InventoryClickEvent " + item);
                    }
                    evt.getCurrentItem().setType(Material.getMaterial(getConfig().getString("Replacement_Item")));
                    evt.setCancelled(true);
                }
            }
        }
        if(getConfig().getBoolean("RevertStackedItems")){
            evt.getWhoClicked().getInventory().forEach(b -> {
                if(b != null){
                    if(b.getAmount() > b.getMaxStackSize()){
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
            if(evt.getCurrentItem() != null){
                if(evt.getCurrentItem().getAmount() > evt.getCurrentItem().getMaxStackSize()){
                    evt.getCurrentItem().setAmount(evt.getCurrentItem().getMaxStackSize());
                }
            }
        }
    }
    @EventHandler
    private void onInventoryPickup(InventoryPickupItemEvent evt){
        if(getConfig().getBoolean("RemoveIllegalBlocksOnPickup")){
            String item = evt.getItem().getType().toString();
            if(getConfig().getBoolean("DEBUG")){
                System.out.println("InventoryPickupItemEvent " + item);
            }
            if (getConfig().getList("BANNED_BLOCKS").contains(item)) {
                evt.setCancelled(true);
            }
        }
        if(getConfig().getBoolean("RevertStackedItems")){
            evt.getInventory().forEach(b -> {
                if(b != null){
                    if(b.getAmount() > b.getMaxStackSize()){
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }
    @EventHandler
    private void onInventoryMove(InventoryMoveItemEvent evt){
        if(getConfig().getBoolean("RemoveIllegalBlocksOnMove")) {
            String item = evt.getItem().getType().toString();
            if (getConfig().getList("BANNED_BLOCKS").contains(item)) {
                if(getConfig().getBoolean("DEBUG")){
                    System.out.println("InventoryMoveItemEvent " + item);
                }
                evt.getItem().setType(Material.getMaterial(getConfig().getString("Replacement_Item")));
                evt.setCancelled(true);
            }
        }
        if(getConfig().getBoolean("RevertStackedItems")){
            if(evt.getItem() != null){
                if(evt.getItem().getAmount() > evt.getItem().getMaxStackSize()){
                    evt.getItem().setAmount(evt.getItem().getMaxStackSize());
                }
            }
        }
    }
    @EventHandler
    private void onBlockPlace(BlockPlaceEvent evt){
        if(getConfig().getBoolean("DEBUG")){
            System.out.println("BLOCKPLACED " + evt.getBlockPlaced());
            System.out.println("BLOCK " + evt.getBlock());
            System.out.println("BLOCKAGAINST " + evt.getBlockAgainst());
            System.out.println("BlockReplacedState " + evt.getBlockReplacedState());
            System.out.println("Hand " + evt.getHand());
            System.out.println("ItemInHand " + evt.getItemInHand());
        }
        if(getConfig().getBoolean("1b1tPlaceBedrock")){
            if(evt.getBlockPlaced().getType().toString().equalsIgnoreCase("BEDROCK")){
                if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_the_end")){
                    evt.setCancelled(true);
                }
                if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world")){
                    if(evt.getBlockPlaced().getY() < 10){
                        evt.setCancelled(true);
                    }
                }
                if(evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")){
                    if(evt.getBlockPlaced().getY() < 10 || evt.getBlockPlaced().getY() > 122){
                        evt.setCancelled(true);
                    }
                }
            }
        }
            if(getConfig().getBoolean("PreventPlacingIllegalBlocks")){
                String block = evt.getBlockPlaced().getType().toString();
                if (getConfig().getList("BANNED_BLOCKS").contains(block)) {
                    if(getConfig().getBoolean("RemoveIllegalBlockOnPlace")){
                        getConfig().getList("BANNED_BLOCKS").forEach(b -> {
                            if(evt.getPlayer().getInventory().contains(Material.getMaterial((String) b))){
                                evt.getPlayer().getInventory().remove(Material.getMaterial((String) b));
                                evt.setCancelled(true);
                            }
                        });
                    }
                    evt.setCancelled(true);
                }
                if(getConfig().getBoolean("RevertStackedItems")){
                    evt.getPlayer().getInventory().forEach(b -> {
                        if(b != null){
                            if(b.getAmount() > b.getMaxStackSize()){
                                b.setAmount(b.getMaxStackSize());
                            }
                        }
                    });
                }
            }
            if(getConfig().getBoolean("PreventChunkBan")){
                Chunk c = evt.getBlock().getChunk();
                Block b = evt.getBlock();
                if(b.getType() == Material.ENCHANTMENT_TABLE){
                    if(checkChunk(Material.ENCHANTMENT_TABLE, c) > config.getInt("MaxEnchantmentTablePerChunk")){
                        if(evt.getPlayer().getLocale().startsWith("es")){
                            evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de mesas de encantamiento / cofres de ender debido al lag.");
                        } else {
                            evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of enchantment tables/end chests due to lag.");
                        }
                        evt.setCancelled(true);
                    }
                } else {
                    if(b.getType() == Material.ENDER_CHEST){
                        if(checkChunk(Material.ENDER_CHEST, c) > config.getInt("MaxEnderchestPerChunk")){
                            if(evt.getPlayer().getLocale().startsWith("es")){
                                evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de mesas de encantamiento / cofres de ender debido al lag.");
                            } else {
                                evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of enchantment tables/end chests due to lag.");
                            }
                            evt.setCancelled(true);
                        }
                    }
                    if(b.getState() instanceof Container){
                        if(checkChunk(b.getType(), c) > config.getInt("MaxContainerPerChunk")){
                            if(evt.getPlayer().getLocale().startsWith("es")){
                                evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de almacenamiento containers debido al lag.");
                            } else {
                                evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of storage containers due to lag.");
                            }
                            evt.setCancelled(true);
                        }
                    } else {
                        if(b.getType() == Material.WALL_SIGN || b.getType() == Material.SIGN_POST){
                            if(checkChunk(b.getType(), c) > config.getInt("MaxSignPerChunk")){
                                if(evt.getPlayer().getLocale().startsWith("es")){
                                    evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de letreros debido al lag");
                                } else {
                                    evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of signs due to lag.");
                                }
                                evt.setCancelled(true);
                            }
                        }
                    }
                }
            }
    }
    static Integer checkChunk(Material material, Chunk c) {
        Integer count = 0;
        int cx = c.getX() << 4;
        int cz = c.getZ() << 4;
        for (int x = cx; x < cx + 16; x++) {
            for (int z = cz; z < cz + 16; z++) {
                for (int y = 0; y < 128; y++) {
                    if (c.getBlock(x, y, z).getType() == material) {
                        count++;
                    }
                }
            }
        }
        return count;
    }
    static void broadcastOp(String s){
        Bukkit.getOnlinePlayers().forEach(b -> {
            if(b.isOp()){
                b.sendMessage(s);
            }
        });
        System.out.println(s);
    }
    @EventHandler
    private void onEntityTeleportEvent(EntityTeleportEvent evt) {
        if(getConfig().getBoolean("PreventEndGatewayCrashExploit")){
            if (evt.getEntity().getWorld().getName().equals("world_the_end") && !evt.getEntity().isEmpty()) {
                evt.setCancelled(true);
                if(!getConfig().getBoolean("NoConsoleOutput")) {
                    System.out.println("Prevented a entity " + "(" + evt.getEntity().getName() + ")" + " from going through end gateway at " + evt.getEntity().getLocation());
                }
            }
        }
    }
    @EventHandler
    private void onEntityChange(BlockPhysicsEvent evt){
        double tps_double = Bukkit.getServer().getTPS()[0];
        if(tps_double < getConfig().getDouble("FallingBlocks")){
            evt.setCancelled(true);
        }
    }
    @EventHandler
    private void onEntityInteract(PlayerInteractAtEntityEvent evt){
        if(getConfig().getBoolean("DisableChestsOnDonkeys")){
                if (evt.getRightClicked() instanceof ChestedHorse) {
                    evt.setCancelled(true);
                    (new BukkitRunnable() {
                        public void run() {
                            if (evt.getPlayer().getInventory().getItemInMainHand().getType() == Material.CHEST) {
                                ((ChestedHorse) evt.getRightClicked()).setCarryingChest(false);
                                //evt.getRightClicked().getWorld().dropItemNaturally(evt.getRightClicked().getLocation(), new ItemStack(Material.CHEST));
                            }
                            ((ChestedHorse) evt.getRightClicked()).setCarryingChest(false);
                        }
                    }).runTaskLater(this, 2L);
                }
        }
    }


    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onCommandPreprocess(PlayerCommandPreprocessEvent evt){
        String msg = evt.getMessage().toLowerCase();
        if(evt.getMessage().equalsIgnoreCase("/newchunks")){
            getServer().getOnlinePlayers().forEach(b -> {
                evt.getPlayer().sendMessage(b.getName() + ": " + newchunks.get(b));
            });
        }
        if(evt.getMessage().equalsIgnoreCase("/oldchunks")){
            getServer().getOnlinePlayers().forEach(b -> {
                evt.getPlayer().sendMessage(b.getName() + ": " + oldchunks.get(b));
            });
        }
        if (evt.getMessage().equalsIgnoreCase("/ignore")) {
            if(getConfig().getBoolean("FixChatcoIgnoreBug")){
                if(evt.getPlayer().getLocale().startsWith("es")){
                    evt.getPlayer().sendMessage("§cNo agregaste un nombre de jugador....");
                } else {
                    evt.getPlayer().sendMessage("§cYou didn't add a player name....");
                }
                evt.setCancelled(true);
            }
        }
        if(getConfig().getBoolean("FixWorldStatsCommandBug")){
            if(evt.getMessage().equalsIgnoreCase("/stats")){
                evt.getPlayer().performCommand("worldstats");
                evt.setCancelled(true);
            }
        }
        if(getConfig().getBoolean("playercommand")){
            if(evt.getMessage().equalsIgnoreCase("/geared")){
                String geared = "";
                String newplayer = "";
                Integer geared_int = 0;
                Integer newplayer_int = 0;
                for(Player c : Bukkit.getServer().getOnlinePlayers()){
                    if(c.getInventory().getChestplate() != null || c.getInventory().getBoots() != null || c.getInventory().getHelmet() != null || c.getInventory().getLeggings() != null){
                        geared = geared + c.getName() + ", ";
                        geared_int++;
                    } else {
                        newplayer = newplayer + c.getName() + ", ";
                        newplayer_int++;
                    }
                }
                evt.getPlayer().sendMessage("Geared players: " + ChatColor.GOLD + geared + ChatColor.WHITE + " (" + geared_int + ")");
                evt.getPlayer().sendMessage("Naked players: " + ChatColor.GOLD + newplayer + ChatColor.WHITE + " (" + newplayer_int + ")");
                evt.getPlayer().sendMessage("Total players: " + ChatColor.GOLD + (newplayer_int + geared_int));
            }
        }
        if(getConfig().getBoolean("playercommand")){
            if(evt.getMessage().startsWith("/elytra")){
                String flying = "";
                String notflying = "";
                Integer flyint = 0;
                Integer noflyint = 0;
                for(Player c : Bukkit.getServer().getOnlinePlayers()){
                    if(c.isGliding()){
                        flying = flying + c.getName() + ", ";
                        flyint++;
                    } else {
                        notflying = notflying + c.getName() + ", ";
                        noflyint++;
                    }
                }
                evt.getPlayer().sendMessage("Flying on elytra: " + ChatColor.GOLD + flying + ChatColor.WHITE + " (" + flyint + ")");
                evt.getPlayer().sendMessage("Not flying on elytra: " + ChatColor.GOLD + notflying + ChatColor.WHITE + " (" + noflyint + ")");
                evt.getPlayer().sendMessage("Total players: " + ChatColor.GOLD + (flyint + noflyint));
            }
        }
        if(evt.getMessage().equalsIgnoreCase("/tps")){
            if(getConfig().getBoolean("UseSparkhealth")){
                evt.getPlayer().performCommand("spark health");
                evt.setCancelled(true);
                Bukkit.getServer().getScheduler().runTaskLater(this, () -> {
                    if(evt.getPlayer().getLocale().startsWith("es")){
                        evt.getPlayer().sendMessage(ChatColor.GRAY + "Este no es el tamaño mundial, para el tipo /stats de tamaño mundial");
                    } else {
                        evt.getPlayer().sendMessage(ChatColor.GRAY + "This is not the world size, for world size type /stats");
                    }
                }, 10L);
            }
        }
        if(evt.getMessage().toLowerCase().startsWith("/nick")){
            if(getConfig().getBoolean("nickresetonly")){
                if(evt.getMessage().equalsIgnoreCase("/nick off")){

                } else {
                    if(evt.getPlayer().getLocale().startsWith("es")){
                        evt.getPlayer().sendMessage("§3No puedes cambiar tu nick pero puedes restablecerlo escribiendo /nick off si tienes un nick viejo!");
                    } else {
                        evt.getPlayer().sendMessage("§3You can't change your nick but you may reset it by typing /nick off if you have a legacy nick!");
                    }
                    evt.setCancelled(true);
                }
            }
        }
        if (evt.getMessage().toLowerCase().startsWith("/tpa ") || evt.getMessage().equalsIgnoreCase("/tpa") || evt.getMessage().toLowerCase().startsWith("/tpahere") || evt.getMessage().toLowerCase().startsWith("/call") || evt.getMessage().toLowerCase().startsWith("/ecall") || evt.getMessage().toLowerCase().startsWith("/etpa") || evt.getMessage().toLowerCase().startsWith("/tpask") || evt.getMessage().toLowerCase().startsWith("/etpask")) {
            if(getConfig().getBoolean("5000blocksawaytoteleport")){
                if (!evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_the_end")) {
                    Point p1 = new Point(evt.getPlayer().getLocation().getBlockX(), evt.getPlayer().getLocation().getBlockZ());
                    Point p2 = new Point(0, 0);
                    if (p1.distance(p2) < 5000) {
                        if(evt.getPlayer().getLocale().startsWith("es")){
                            evt.getPlayer().sendMessage("§3Necesitas ser 5000 cuadras de spawn para teletransportarse!");
                        } else {
                            evt.getPlayer().sendMessage("§3You need to be 5000 blocks away from spawn to teleport!");
                        }
                        evt.setCancelled(true);
                    }
                }
            }
        }
        if(getConfig().getBoolean("AllowOPStobypass")){
            if(getConfig().getList("CommandsWhitelisted").contains(msg.split(" ")[0])) {
            } else {
                if(getConfig().getBoolean("CommandWhitelist")){
                    if(!evt.getPlayer().isOp()){
                        if(evt.getPlayer().getLocale().startsWith("es")){
                            evt.getPlayer().sendMessage("§4Mal comando. Tipo /help para todos los comandos.");
                        } else {
                            evt.getPlayer().sendMessage("§4Bad command. Type /help for all commands.");
                        }
                        evt.setCancelled(true);
                    }
                }
            }
        } else {
            if(getConfig().getList("CommandsWhitelisted").contains(msg.split(" ")[0])) {
            } else {
                if(getConfig().getBoolean("CommandWhitelist")){
                    if(evt.getPlayer().getLocale().startsWith("es")){
                        evt.getPlayer().sendMessage("§4Mal comando. Tipo /help para todos los comandos.");
                    } else {
                        evt.getPlayer().sendMessage("§4Bad command. Type /help for all commands.");
                    }
                    evt.setCancelled(true);
                }
            }
        }

    }

    // shit skidded from john200410, just added another packet to check. msg me if you want removed
    public HashMap<Player, Integer> a = new HashMap<Player, Integer>();
    public HashMap<Player, Integer> b = new HashMap<Player, Integer>();
    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        if(getConfig().getBoolean("PreventGodMode")){
            injectPlayer(event.getPlayer());
            a.put(event.getPlayer(), 0);
            b.put(event.getPlayer(), 0);
        }
        if(getConfig().getBoolean("DisableNCPGeyser")){
            String ip = event.getPlayer().getAddress().toString().replace("/", "").replaceAll(":(.*)", "");
            if(ip.contains("127.0.0.1")){
                getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(), "pex user " + event.getPlayer().getName() + " add nocheatplus.shortcut.bypass");
            }
        }
    }

    @EventHandler
    public void onLogin(PlayerLoginEvent evt){
        if(getConfig().getBoolean("BypassSlots")) {
            if (evt.getResult() == PlayerLoginEvent.Result.KICK_FULL) {
                evt.allow();
            }
        }
    }
    @EventHandler
    public void onLeave(PlayerQuitEvent event) {
        if(getConfig().getBoolean("PreventGodMode")){
            removePlayer(event.getPlayer());
            a.put(event.getPlayer(), 0);
            b.put(event.getPlayer(), 0);
        }
        if(getConfig().getBoolean("DisableNCPGeyser")){
            String ip = event.getPlayer().getAddress().toString().replace("/", "").replaceAll(":(.*)", "");
            if(ip.contains("127.0.0.1")){
                getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(), "pex user " + event.getPlayer().getName() + " remove nocheatplus.shortcut.bypass");
            }
        }
    }

//    HashSet<String> whitelisted = new HashSet<>();
//    HashMap<String, Double> speeds = new HashMap<>();
//    @EventHandler
//    public void onMoveAC(PlayerMoveEvent evt){
//        if(getConfig().getBoolean("GeyserFlyPatch")){
//            if(evt.getPlayer().getName().contains("moom0o")){
//                if(!evt.getPlayer().isGliding()){
//                    Location from = evt.getFrom();
//                    Location to = evt.getTo();
//                    double distX = to.getX() - from.getX();
//                    double distZ = to.getZ() - from.getZ();
//                    double distY = to.getY() - from.getY();
//                    double finalValue = Math.hypot(distX, distZ);
//                    Integer x = to.getBlockX();
//                    Integer y = to.getBlockY();
//                    Integer z = to.getBlockZ();
//                    Integer xx = from.getBlockX();
//                    Integer yy = from.getBlockY();
//                    Integer zz = from.getBlockZ();
//                    Integer xxx = evt.getPlayer().getLocation().getBlockX();
//                    Integer yyy = evt.getPlayer().getLocation().getBlockY();
//                    Integer zzz = evt.getPlayer().getLocation().getBlockZ();
//                    speeds.put(evt.getPlayer().getName(), finalValue);
//                    evt.getPlayer().sendMessage("FROM: " + evt.getPlayer().getWorld().getBlockAt(xx, yy-1, zz).getType());
//                    evt.getPlayer().sendMessage("TO: " + evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType());
//
//                    if((evt.getPlayer().getWorld().getBlockAt(xx, yy-1, zz).getType() != Material.AIR && evt.getPlayer().getWorld().getBlockAt(xx, yy-2, zz).getType() != Material.AIR)){
//                        if(evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType() == Material.AIR){
//                            evt.getPlayer().sendMessage("WHITELISTED");
//                            whitelisted.add(evt.getPlayer().getName());
//                            Bukkit.getServer().getScheduler().runTaskLater(this, () -> {
//                                whitelisted.remove(evt.getPlayer().getName());
//                                evt.getPlayer().sendMessage("UNWHITELISTED");
//
//                            }, 1 * 20L);
//                        }
//                    }
//                    if(!whitelisted.contains(evt.getPlayer().getName())){
//                        if((evt.getPlayer().getWorld().getBlockAt(xx, yy-1, zz).getType() == Material.AIR && evt.getPlayer().getWorld().getBlockAt(xx, yy-2, zz).getType() == Material.AIR)){
//                            if(evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType() == Material.AIR && evt.getPlayer().getWorld().getBlockAt(x, y-2, z).getType() == Material.AIR){
//                                if(distY > -0.02442408821369213){
//                                    evt.setCancelled(true);
//
//                                }
//                            }
//                        }
//                    }
//                }
//            }
//
//        }
//    }

    @EventHandler
    public void onMoveevt(PlayerMoveEvent event) {
        if(getConfig().getBoolean("PreventGodMode")){
            if(event.getPlayer().getVehicle() != null) {
                a.put(event.getPlayer(), 1);
                if(b.get(event.getPlayer()) != null){
                    if(b.get(event.getPlayer()) > 3) {
                        Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.RED + "" + event.getPlayer() + " tried getting into godmode");
                        event.getPlayer().leaveVehicle();
                        a.put(event.getPlayer(), 0);
                        b.put(event.getPlayer(), 0);
                    }
                }
            }
        }
    }

    private void removePlayer(Player player) {
        Channel channel = ((CraftPlayer) player).getHandle().playerConnection.networkManager.channel;
        channel.eventLoop().submit(()-> {
            channel.pipeline().remove(player.getName());
            return null;
        });
    }

    private void injectPlayer(Player player) {
        ChannelDuplexHandler channelDuplexHandler = new ChannelDuplexHandler(){

            @Override
            public void channelRead(ChannelHandlerContext channelHandlerContext, Object packet) throws Exception{
                if((packet instanceof PacketPlayInFlying.PacketPlayInPosition || packet instanceof PacketPlayInFlying.PacketPlayInPositionLook) && a.get(player) > 0) {
                    int count = b.containsKey(player) ? b.get(player) : 0;
                    b.put(player, count + 1);
                    a.put(player, 0);
                }
                super.channelRead(channelHandlerContext, packet);
            }

            @Override
            public void write(ChannelHandlerContext channelHandlerContext, Object packet, ChannelPromise channelPromise) throws Exception {
                super.write(channelHandlerContext, packet, channelPromise);
            }

        };

        ChannelPipeline pipeline = ((CraftPlayer) player).getHandle().playerConnection.networkManager.channel.pipeline();
        pipeline.addBefore("packet_handler", player.getName(), channelDuplexHandler);

    }
    private final static String HTTP_REGEX_CHECK = "(https?://(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?://(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})";
    private final static String REGEX_CHECK = "[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z()]{1,6}\\b([-a-zA-Z()@:%_+.~#?&//=]*)";
    HashSet<String> antispam = new HashSet<String>();
    HashSet<String> words = new HashSet<String>();
    @EventHandler
    private void onChat(AsyncPlayerChatEvent event) {
        if(antispam.contains(event.getPlayer().getName())){
            event.setCancelled(true);
            System.out.println(event.getPlayer().getName() + " FAILED to send message due to slowmode: " + event.getMessage());
        } else {
            antispam.add(event.getPlayer().getName());
            Bukkit.getServer().getScheduler().runTaskLater(this, () -> {
                antispam.remove(event.getPlayer().getName());
            }, getConfig().getInt("AntiSpamTime") * 20L);
        }
        if(words.contains(event.getMessage())){
            event.setCancelled(true);
            System.out.println(event.getPlayer().getName() + " FAILED to send message due to duplicate message: " + event.getMessage());

        } else {
            if(event.getMessage().length() > 10){
                words.add(event.getMessage());
                Bukkit.getServer().getScheduler().runTaskLater(this, () -> {
                    words.remove(event.getMessage());
                }, getConfig().getInt("AntiSpamWordTime") * 20L);
            }
        }
        if(getConfig().getBoolean("Replace@")){
            if(event.getMessage().contains("@")) {
                event.setMessage(event.getMessage().replaceAll("@", ""));
                event.getPlayer().sendMessage("stop trying to ping me faggot");
            }
        }
        if(getConfig().getBoolean("Preventlinks")){
                    /*
        code from John200410
         */
            final World playerWorld = event.getPlayer().getWorld();

            //check if player is in overworld
            if(!playerWorld.getName().equals("world")) {
                return;
            }
            final Location location = event.getPlayer().getLocation();

            //check distance from the world spawn
            if(location.distance(playerWorld.getSpawnLocation()) > 1000) {
                return;
            }

            //check if message contains a link
            final String msg = event.getMessage();

            //loop through each word
            for (String string : msg.split(" ")) {
                //check if it is a link
                if(string.matches(REGEX_CHECK) || string.matches(HTTP_REGEX_CHECK)) {
                    if(!(event.getPlayer().getName() == "moooomoooo")){
                        System.out.println(event.getPlayer().getName());
                        System.out.println("Prevented " + event.getPlayer().getName() + " from sending " + event.getMessage() + " because link");
                        event.setCancelled(true);
                    }
                }
            }
        }
    }
}
