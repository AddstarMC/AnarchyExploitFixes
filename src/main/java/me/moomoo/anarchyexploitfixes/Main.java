package me.moomoo.anarchyexploitfixes;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import me.moomoo.anarchyexploitfixes.misc.*;
import me.moomoo.anarchyexploitfixes.patches.*;
import me.moomoo.anarchyexploitfixes.prevention.*;
import org.bukkit.*;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;

import java.awt.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.logging.Logger;

public class Main extends JavaPlugin implements Listener {
    public static final Integer[] old_total = {0};
    public static final Integer[] new_total = {0};
    public final HashMap<Player, Integer> newChunks = new HashMap<>();
    public final HashMap<Player, Integer> oldChunks = new HashMap<>();
    public HashSet<String> crafting = new HashSet<>();
    public HashMap<Player, Integer> levels = new HashMap<>();
    public HashMap<Player, Integer> boatLevels = new HashMap<>();
    public FileConfiguration config = getConfig();
    public ProtocolManager protocolManager;
    public PluginManager pluginManager;
    private Logger log;

    @Override
    public void onEnable() {
        log = getLogger();
        pluginManager = getServer().getPluginManager();
        log.info("Registering events");
        // please make a pull request if there is a better way to do this
        // b
        register(
                new DupeFixes(this), new DisableWithers(this),
                new Elytra(this), new EndPortalPatch(this),
                new Bedrock(this), new Boats(this),
                new Chat(this), new ChunkBan(this),
                new CommandPreProcess(this), new CrashExploits(this),
                new Illegals(this), new JoinMessages(this),
                new Kicks(this), new LagExploits(this),
                new MyServer(this), new NetherRoof(this),
                new Redstone(this), new NetherPortals(this),
                new GodMode(this), new RenderDistance(this),
                new CommandExploits(this)
        );
        if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
            // I would put this in a seperate class if I could however I cba to deal with the annoying ass static errors.
            getLogger().info("Detected ProtocolLib!");
            protocolManager = ProtocolLibrary.getProtocolManager();
            if (config.getBoolean("PreventCraftingRecipeLagExploit")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.NORMAL, PacketType.Play.Client.AUTO_RECIPE) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                if (event.getPacketType() == PacketType.Play.Client.AUTO_RECIPE) {
                                    if (crafting.contains(event.getPlayer().getName())) {
                                        event.setCancelled(true);

                                    } else {
                                        crafting.add(event.getPlayer().getName());
                                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> crafting.remove(event.getPlayer().getName()), getConfig().getInt("CraftingRecipeDelay"));
                                    }
                                }
                            }
                        });
            }
            if (config.getBoolean("PreventPacketFly")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.HIGHEST, PacketType.Play.Client.TELEPORT_ACCEPT) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                Player e = event.getPlayer();
                                Location l = event.getPlayer().getLocation();
                                if (event.getPlayer().getWorld().getBlockAt(l.getBlockX(), l.getBlockY() - 1, l.getBlockZ()).getType() == Material.AIR && !e.isGliding() && !e.isInsideVehicle()) {
                                    if (event.getPacketType() == PacketType.Play.Client.TELEPORT_ACCEPT) {
                                        if (levels.get(e) != null) {
                                            if (levels.get(e) > getConfig().getInt("MaxTeleportPacketsPer10Seconds")) {
                                                event.setCancelled(true);
                                                if (getConfig().getBoolean("LogPacketFlyEvents")) {
                                                    getLogger().warning(e.getName() + " prevented from packetflying");
                                                }
                                            } else {
                                                levels.merge(e, 1, Integer::sum);
                                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e, levels.get(e) - 1), 200L);
                                            }
                                        } else {
                                            levels.put(e, 1);
                                            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e, levels.get(e) - 1), 200L);
                                        }
                                    }
                                }
                            }
                        });
            }
            if (config.getBoolean("BoatflyPatch")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.HIGHEST, PacketType.Play.Client.USE_ENTITY) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                Player e = event.getPlayer();
                                if (e.isInsideVehicle() && e.getVehicle().getType() == EntityType.BOAT) {
                                    if (event.getPacketType() == PacketType.Play.Client.USE_ENTITY) {
                                        if (boatLevels.get(e) != null) {
                                            if (boatLevels.get(e) > getConfig().getInt("MaxEntityPacketsPer10Seconds")) {
                                                e.getVehicle().remove();
                                                if (getConfig().getBoolean("LogBoatFlyEvents")) {
                                                    getLogger().warning(e.getName() + " prevented from boatflying");
                                                }
                                            } else {
                                                boatLevels.merge(e, 1, Integer::sum);
                                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e, boatLevels.get(e) - 1), 200L);
                                            }
                                        } else {
                                            boatLevels.put(e, 1);
                                            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e, boatLevels.get(e) - 1), 200L);
                                        }
                                    }
                                }
                            }
                        });
            }
        } else {
            getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
        }
        log.info("Registering events finished");
        log.info("Registering commands");
        getCommand("aef").setExecutor(new Commands(this));
        if (config.getBoolean("StrictIllegalPrevention")) {
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> e.getInventory().forEach(this::revert))), 0L, 20L);
        }
        if (config.getBoolean("RemoveAllWitherSkulls")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Entity e : w.getEntities()) {
                        if (e.getType() == EntityType.WITHER_SKULL) {
                            e.remove();
                        }
                    }
                }
            }, 0L, 20L);
        }
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            new_total[0] = 0;
            old_total[0] = 0;
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (newChunks.get(b) != null) {
                    new_total[0] = new_total[0] + newChunks.get(b);
                }
            });
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (oldChunks.get(b) != null) {
                    old_total[0] = old_total[0] + oldChunks.get(b);
                }
            });
        }, 0L, 20L);

        if (config.getBoolean("RateLimitLevers"))
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, Redstone::clearLeverHashmap, 0, config.getInt("RateLimitTime"));

        saveDefaultConfig();
        // Disable some config options for non 1.12 servers because they cause a shit ton of errors
        if (!config.getBoolean("OverideConfigChanges")) {
            if (!Bukkit.getVersion().contains("1.12")) {
                getConfig().set("RemoveALLIllegalBlocksOnCHUNKLOAD", false);
                getConfig().set("FillInBedrockFloor", false);
                getConfig().set("FillInBedrockRoof", false);
                getConfig().set("ExperimentalDupePatch2", false);
                log.warning("Disabled:\nRemoveALLIllegalBlocksOnCHUNKLOAD\nFillInBedrockFloor\nFillInBedrockRoof\nExperimentalDupePatch2\nDue to errors with non 1.12.2 versions.");
            } else {
                getConfig().set("DisableFish", false);
                log.warning("Disabled:\nDisableFish\nbecause server is 1.12");
            }
        }
        if (config.getBoolean("ExperimentalDupePatch2")) {
            Bukkit.getScheduler().runTaskTimer(this, this::preventDespawning, 0L, 20L);
        }
        log.info("[ENABLED] AnarchyExploitFixes - Made by moomoo");

        new Metrics(this, 8700);
    }

    public void onDisable() {
        log.info("[DISABLED] AnarchyExploitFixes - Made by moomoo");
    }

    public Integer checkChunk(Material material, Chunk c) {
        if (Bukkit.getVersion().contains("1.12") || config.getBoolean("OverideConfigChanges")) {
            int count = 0;
            int cx = c.getX() << 4;
            int cz = c.getZ() << 4;

            for (int x = cx; x < cx + 16; x++) {
                for (int z = cz; z < cz + 16; z++) {
                    for (int y = 0; y < 256; y++) {
                        if (c.getBlock(x, y, z).getType() == material) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        return 0;
    }

    public void revert(ItemStack c) {
        if (c != null) {
            if (config.getBoolean("RevertStackedItems")) {
                if (config.getBoolean("OnlyRevertStacksForCertainItems")) {
                    for (String s : config.getStringList("RevertStackedItemsList")) {
                        if (c.getType().name().equals(s)) {
                            if (c.getAmount() > c.getMaxStackSize()) {
                                c.setAmount(c.getMaxStackSize());
                            }
                        }
                    }
                } else {
                    if (c.getAmount() > c.getMaxStackSize()) {
                        c.setAmount(c.getMaxStackSize());
                    }
                }
            }
            if (config.getBoolean("RevertEnchantments")) {
                Illegals.revertEnchantments(c);
            }
            if (config.getBoolean("RemoveIllegalHeads")) {
                if (c.getType().equals(Material.SKULL_ITEM)) {
                    SkullMeta sm = (SkullMeta) c.getItemMeta();
                    if (sm.hasOwner() || c.getData().toString().equals("SKULL_ITEM(3)")) {
                        c.subtract(c.getAmount());
                    }
                }
            }
            if (config.getList("BANNED_BLOCKS").contains(c.getType().name())) {
                c.subtract(c.getAmount());
            }
        }
    }


    public void preventDespawning() {
        for (World w : Bukkit.getWorlds()) {
            for (Entity e : w.getEntities()) {
                if (e instanceof LivingEntity) {
                    ((LivingEntity) e).setRemoveWhenFarAway(!isEntityCloseToPlayer(e));
                }
            }
        }
    }

    public boolean isEntityCloseToPlayer(Entity e) {
        for (Player p : Bukkit.getOnlinePlayers()) {
            Point p1 = new Point(p.getLocation().getBlockX(), p.getLocation().getBlockZ());
            Point p2 = new Point(e.getLocation().getBlockX(), e.getLocation().getBlockZ());
            if (p1.distance(p2) < 500) {
                return true;
            }
        }
        return false;
    }

    private void register(Listener... list) {
        pluginManager.registerEvents(this, this);
        for (Listener listener : list) {
            pluginManager.registerEvents(listener, this);
        }
    }
}
