package me.moomoo.anarchyexploitfixes;

import io.netty.channel.*;
import net.minecraft.server.v1_12_R1.PacketPlayInFlying;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.block.Container;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.craftbukkit.v1_12_R1.entity.CraftPlayer;
import org.bukkit.entity.*;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockDamageEvent;
import org.bukkit.event.block.BlockPhysicsEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.block.BlockRedstoneEvent;
import org.bukkit.event.entity.*;
import org.bukkit.event.inventory.*;
import org.bukkit.event.player.*;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;

import java.awt.*;
import java.time.Instant;
import java.util.HashMap;
import java.util.HashSet;

public class Main extends JavaPlugin implements Listener {
    private final FileConfiguration config = getConfig();
    private final HashMap<Player, Integer> newchunks = new HashMap<>();
    private final HashMap<Player, Integer> oldchunks = new HashMap<>();

    public static final Integer[] old_total = {0};
    public static final Integer[] new_total = {0};

    private final static String HTTP_REGEX_CHECK = "(https?://(?:www\\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|www\\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\\.[^\\s]{2,}|https?://(?:www\\.|(?!www))[a-zA-Z0-9]+\\.[^\\s]{2,}|www\\.[a-zA-Z0-9]+\\.[^\\s]{2,})";
    private final static String REGEX_CHECK = "[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z()]{1,6}\\b([-a-zA-Z()@:%_+.~#?&/=]*)";
    HashSet<String> antispam = new HashSet<>();
    HashSet<String> words = new HashSet<>();

    public HashSet<String> playersinnewchunks = new HashSet<>();

    // shit skidded from john200410, just added another packet to check. msg me if you want removed
    public HashMap<Player, Integer> a = new HashMap<>();
    public HashMap<Player, Integer> b = new HashMap<>();

    @Override
    public void onEnable() {
        if (config.getBoolean("BoatflyPatchStrict")) {
            if (config.getBoolean("PreventGodMode")) {
                for (Player p : Bukkit.getOnlinePlayers()) {
                    removePlayer(p);
                    injectPlayer(p);
                    a.put(p, 0);
                    b.put(p, 0);
                }
            }

            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> {
                if (e.isInsideVehicle()) {
                    int x = e.getLocation().getBlockX();
                    int y = e.getLocation().getBlockY();
                    int z = e.getLocation().getBlockZ();
                    // ik its a mess idgaf
                    if ((e.getWorld().getBlockAt(x, y - 1, z).getType() == Material.AIR) && e.getWorld().getBlockAt(x, y - 2, z).getType() == Material.AIR && e.getWorld().getBlockAt(x, y - 3, z).getType() == Material.AIR) {
                        if (e.getVehicle() instanceof Boat) {
                            e.getVehicle().remove();
                            if (config.getBoolean("BoatflyMessage")) {
                                e.sendMessage(ChatColor.GOLD + "Boatfly disabled due to an exploit >:) If you aren't boat flying, boats on land are a little buggy.");
                            }
                        }
                    }
                }
            })), 0L, config.getInt("BoatflyPatchStrictCheckRate"));
        }

        if (config.getBoolean("StrictIllegalPrevention")) {
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> e.getInventory().forEach(bb -> {
                if (bb != null) {
                    if (bb.getAmount() > bb.getMaxStackSize()) {
                        bb.setAmount(bb.getMaxStackSize());
                    }
                }
            }))), 0L, 20L);
        }

        Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> {
            if (newchunks.get(e) != null) {
                if (!e.isOp()) {
                    if (newchunks.get(e) > 60) {
                        broadcastOp(ChatColor.RED + e.getName() + " is generating a lot of chunks per second! (" + newchunks.get(e) + ")");
                    }
                }
            }
        })), 0L, 20L);

        Bukkit.getScheduler().runTaskTimer(this, () -> {
            new_total[0] = 0;
            old_total[0] = 0;
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (newchunks.get(b) != null) {
                    new_total[0] = new_total[0] + newchunks.get(b);
                }
            });
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (oldchunks.get(b) != null) {
                    old_total[0] = old_total[0] + oldchunks.get(b);
                }
            });
        }, 0L, 20L);

        saveDefaultConfig();

        getLogger().info("[ENABLED] AnarchyExploitFixes - Made by moomoo");
        Bukkit.getServer().getPluginManager().registerEvents(this, this);

        new Metrics(this, 8700);

        if (Bukkit.getPluginManager().getPlugin("PlaceholderAPI") != null) {
            new Expansions(this).register();
        }
    }

    public void onDisable() {
        getLogger().info("[DISABLED] AnarchyExploitFixes - Made by moomoo");
    }

    @EventHandler
    public void onElytra(EntityToggleGlideEvent evt) {
        if (config.getBoolean("DisableAllElytras")) {
            evt.setCancelled(true);
            evt.getEntity().sendMessage("Elytras currently disabled due to LAG exploit.");
        }
    }

    @EventHandler
    public void onProjectileLaunch(ProjectileLaunchEvent evt) {
        String entity = evt.getEntity().toString(); // The entity
        if (config.getBoolean("DisableWithers")) {
            if (entity.equals("CraftWitherSkull")) {
                evt.setCancelled(true);
            }
        }
    }

    @EventHandler
    private void onPlayerBucketEvent(PlayerBucketEmptyEvent evt) {
        if (config.getBoolean("PreventDestroyingEndPortals")) {
            String playerName = evt.getPlayer().getName();
            Material type = evt.getBlockClicked().getType();
            BlockFace face = evt.getBlockFace();
            String world = evt.getBlockClicked().getWorld().getName();

            if (config.getBoolean("DEBUG")) {
                getLogger().info("PlayerBucketEmptyEvent " + face + " " + type);
            }

            final boolean isAround = face == BlockFace.NORTH || face == BlockFace.EAST || face == BlockFace.SOUTH || face == BlockFace.WEST;

            if (type == Material.BEDROCK) {
                if (world.equalsIgnoreCase("world_the_end")) {
                    if (isAround) {
                        evt.setCancelled(true);
                        getLogger().info("Prevented " + playerName + " from destroying a portal!");
                    }
                }
            }

            if (type == Material.ENDER_PORTAL_FRAME) {
                if (isAround) {
                    evt.setCancelled(true);
                    getLogger().info("Prevented " + playerName + " from destroying a portal!");
                }
            }

            if (face == BlockFace.UP || face == BlockFace.DOWN) {
                if (evt.getPlayer().getWorld().getBlockAt(evt.getBlockClicked().getX(), evt.getBlockClicked().getY() - 1, evt.getBlockClicked().getZ()).getType() == Material.ENDER_PORTAL || evt.getPlayer().getWorld().getBlockAt(evt.getBlockClicked().getX(), evt.getBlockClicked().getY() + 1, evt.getBlockClicked().getZ()).getType() == Material.ENDER_PORTAL) {
                    evt.setCancelled(true);
                    getLogger().info("Prevented " + playerName + " from destroying a portal!");
                }
            }
        }
    }

    @EventHandler
    private void onEntityPortalEvent(EntityPortalEvent evt) {
        if (config.getBoolean("PreventDonkeysFromGoingThroughPortals")) {
            Entity entity = evt.getEntity();
            if (config.getBoolean("DEBUG")) {
                getLogger().info("EntityPortalEvent  " + entity);
            }
            if (entity instanceof ChestedHorse) {
                if (((ChestedHorse) entity).isCarryingChest()) {
                    evt.setCancelled(true);
                    if (!config.getBoolean("NoConsoleOutput")) {
                        getLogger().info("Prevented a " + entity.toString() + " from going through portal");
                    }
                }
            }
        }
    }

    //    @EventHandler
//    private void onLightUpdate(Light)
//    private HashSet<String> blockplace = new HashSet<String>();
//    @EventHandler
//    private void onBlockBreak(BlockPlaceEvent evt){
//        if(config.getBoolean("LightLagFix")){
//            if(evt.getBlock().getWorld().getBlockAt(evt.getBlock().getX(), evt.getBlock().getY() -1, evt.getBlock().getZ()).getType() == Material.AIR){
//                if(blockplace.contains(String.valueOf(evt.getBlock().getX() + evt.getBlock().getY() + evt.getBlock().getZ()))){
//                    evt.setCancelled(true);
//                    evt.getPlayer().sendMessage("Please wait a bit!");
//                } else {
//                    getLogger().info(evt.getBlock().getWorld().getBlockAt(evt.getBlock().getX(), evt.getBlock().getY() -1, evt.getBlock().getZ()));
//                    blockplace.add(String.valueOf(evt.getBlock().getX() + evt.getBlock().getY() + evt.getBlock().getZ()));
//                }
//            }
//
//        }
//    }
    @EventHandler
    private void onPlayerInteractEvent(PlayerInteractEvent evt) {
        if (config.getBoolean("RemoveIllegalBlocksOnInteract")) {
            if (evt.getClickedBlock() != null) {
                if (evt.getClickedBlock().getState() instanceof Container) {
                    if (config.getBoolean("DEBUG")) {
                        getLogger().info("PlayerInteractEvent " + evt.getClickedBlock().getType().toString());
                    }
                    config.getList("BANNED_BLOCKS").forEach(b -> ((Container) evt.getClickedBlock().getState()).getInventory().remove(Material.getMaterial((String) b)));
                }
            }
        }
    }

    @EventHandler
    private void onPlayerJoinEvent(PlayerJoinEvent evt) {
        getLogger().info("Player " + evt.getPlayer().getName() + " language = " + evt.getPlayer().getLocale());
        if (config.getBoolean("RemoveIllegalBlocksOnJoin")) {
            config.getList("BANNED_BLOCKS").forEach(b -> {
                if (config.getBoolean("DEBUG")) {
                    getLogger().info("PlayerJoinEvent");
                }
                evt.getPlayer().getInventory().remove(Material.getMaterial((String) b));
            });
        }

        if (config.getBoolean("GrayJoinLeaveMessages")) {
            evt.setJoinMessage("§7" + evt.getPlayer().getName() + " " + config.getString("JoinMessage"));
        }

        if (config.getBoolean("RevertStackedItems")) {
            evt.getPlayer().getInventory().forEach(b -> {
                if (b != null) {
                    if (b.getAmount() > b.getMaxStackSize()) {
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }

    @EventHandler
    private void onPlayerLeave(PlayerQuitEvent evt) {
        if (config.getBoolean("GrayJoinLeaveMessages")) {
            evt.setQuitMessage("§7" + evt.getPlayer().getName() + " " + config.getString("LeaveMessage"));
        }
    }

    @EventHandler
    private void onInventoryOpenEvent(InventoryOpenEvent evt) {
        if (config.getBoolean("RemoveIllegalBlocksOnInventoryOpen")) {
            config.getList("BANNED_BLOCKS").forEach(b -> {
                if (config.getBoolean("DEBUG")) {
                    getLogger().info("InventoryOpenEvent");
                }
                evt.getPlayer().getInventory().remove(Material.getMaterial((String) b));
            });
        }

        if (config.getBoolean("RevertStackedItems")) {
            evt.getPlayer().getInventory().forEach(b -> {
                if (b != null) {
                    if (b.getAmount() > b.getMaxStackSize()) {
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }

    @EventHandler
    private void onBlockDropItemEvent(PlayerDropItemEvent evt) {
        if (config.getBoolean("DEBUG")) {
            getLogger().info("§6DEBUG: " + evt.getItemDrop().getItemStack().getType().toString());
        }

        if (config.getBoolean("RemoveIllegalBlocksOnDrop")) {
            if (config.getBoolean("DEBUG")) {
                getLogger().info("PlayerDropItemEvent");
            }

            String item = evt.getItemDrop().getItemStack().getType().toString();

            if (config.getList("BANNED_BLOCKS").contains(item)) {
                evt.getItemDrop().getItemStack().setType(Material.getMaterial(config.getString("Replacement_Item")));
                evt.getPlayer().getInventory().remove(Material.BEDROCK);
                evt.setCancelled(true);
            }
        }

        if (config.getBoolean("RevertStackedItems")) {
            evt.getPlayer().getInventory().forEach(b -> {
                if (b != null) {
                    if (b.getAmount() > b.getMaxStackSize()) {
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }

    @EventHandler
    public void onTeleport(PlayerTeleportEvent evt) {
        if (config.getBoolean("PreventNetherRoof")) {
            if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                if (!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")) {
                    if (evt.getFrom().getY() < 128 && evt.getTo().getY() >= 128) {
                        evt.getPlayer().teleport(evt.getFrom());
                    }
                }
            }
        }
    }

    @EventHandler
    public void PlayerMove(PlayerMoveEvent evt) {
        if (config.getBoolean("PreventNetherRoof")) {
            if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                if (!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")) {
                    if (evt.getTo().getY() >= 128) {
                        evt.getPlayer().teleport(new Location(evt.getPlayer().getWorld(), evt.getPlayer().getLocation().getX(), 120, evt.getPlayer().getLocation().getZ()));
                        evt.getPlayer().performCommand("vote");
                    }
                }
            }

            if (evt.getPlayer().isInsideVehicle()) {
                if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                    if (!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")) {
                        if (evt.getPlayer().getLocation().getY() > 127) {
                            evt.getPlayer().leaveVehicle();
                            evt.getPlayer().performCommand("vote");
                        }
                    }
                }
            }

            if (evt.getPlayer().isGliding()) {
                if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                    if (!evt.getPlayer().hasPermission("anarchyexploitfixes.netherroofbypass")) {
                        if (evt.getPlayer().getLocation().getY() > 127) {
                            evt.getPlayer().setGliding(false);
                            evt.getPlayer().performCommand("vote");
                        }
                    }
                }
            }
        }

        if (evt.getPlayer().isGliding()) {
            Location from = evt.getFrom();
            Location to = evt.getTo();
            double distX = to.getX() - from.getX();
            double distZ = to.getZ() - from.getZ();
            double finalValue = Math.hypot(distX, distZ);
            double tps = Bukkit.getServer().getTPS()[0];
            if (tps < config.getDouble("Elytra")) {
                Player player = evt.getPlayer();
                PlayerInventory i = player.getInventory();
                Location l = i.getLocation();
                if (evt.getPlayer().getLocale().startsWith("es")) {
                    evt.getPlayer().sendActionBar(ChatColor.DARK_RED + "Los Elytras están actualmente deshabilitados porque el tps es mas bajo que " + config.getInt("Elytra"));
                } else {
                    evt.getPlayer().sendActionBar(ChatColor.DARK_RED + "Elytras are currently disabled because the tps is lower than " + config.getInt("Elytra"));
                }
                evt.setCancelled(true);
                if (config.getBoolean("RemoveElytra")) {
                    evt.getPlayer().setGliding(false);
                    if (i.getChestplate() != null && i.getChestplate().getType().equals(Material.ELYTRA)) {
                        ItemStack elytra = i.getChestplate();
                        i.setChestplate(null);
                        l.getWorld().dropItemNaturally(l, elytra);
                    }
                }
            } else {
                if (playersinnewchunks.contains(evt.getPlayer().getName())) {
                    if (evt.getPlayer().getLocation().getY() > 127 && evt.getPlayer().getWorld().getName().equals("world_nether")) {
                        if (finalValue > 0.5) {
                            if (config.getBoolean("PreventNetherRoof")) {
                                evt.setCancelled(true);
                                if (evt.getPlayer().getLocale().startsWith("es")) {
                                    evt.getPlayer().sendMessage("Solo puedes ir en chunks viejos en el techo. Desequipa tus élitros para dejar de volar.");
                                } else {
                                    evt.getPlayer().sendMessage("You can only go in old chunks on the roof. Unequip your elytra to stop flying.");
                                }
                            }
                        }
                    } else {
                        if (finalValue > (config.getDouble("ElytraNewChunkSpeed") + 0.02) && !evt.getPlayer().isOp()) {
                            evt.setCancelled(true);

                            if (evt.getPlayer().getLocale().startsWith("es")) {
                                evt.getPlayer().sendActionBar(ChatColor.RED + "Baja la configuración de tu élitro, la velocidad está restringida en nuevos chunks.");
                            } else {
                                evt.getPlayer().sendActionBar(ChatColor.RED + "Turn down your elytra settings, speed is restricted in new chunks.");
                            }

                            evt.getPlayer().playSound(evt.getPlayer().getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0F, 1.0F);
                            if (config.getBoolean("SendClientInstructions")) {
                                if (!evt.getPlayer().getLocale().equals("es")) {
                                    evt.getPlayer().sendMessage(" ");
                                    evt.getPlayer().sendMessage(ChatColor.GRAY + "Change your elytra hack settings to this");
                                    evt.getPlayer().sendMessage(" ");
                                    evt.getPlayer().sendMessage(ChatColor.RED + "Future settings: Speed " + Math.round((config.getDouble("ElytraNewChunkSpeed") * 10) * 100.0) / 100.0);
                                    evt.getPlayer().sendMessage(ChatColor.BLUE + "KAMI BLUE settings: Speed " + Math.round(config.getDouble("ElytraNewChunkSpeed") * 100.0) / 100.0);
                                    evt.getPlayer().sendMessage(" ");
                                }
                            }
                        } else {
                            if (config.getBoolean("ElytraActionBar")) {
                                if (evt.getPlayer().getLocale().startsWith("es")) {
                                    evt.getPlayer().sendActionBar(ChatColor.GRAY + "Estás volando en" + ChatColor.DARK_RED + " NUEVO" + ChatColor.GRAY + " chunks. Velocidad: " + (String.format("%.2f", Math.min((double) Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY + config.getDouble("ElytraNewChunkSpeed")));
                                } else {
                                    evt.getPlayer().sendActionBar(ChatColor.GRAY + "You are flying in" + ChatColor.DARK_RED + " NEW" + ChatColor.GRAY + " chunks. Speed: " + (String.format("%.2f", Math.min((double) Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY + config.getDouble("ElytraNewChunkSpeed")));
                                }
                            }
                        }
                    }
                } else {
                    if (finalValue > (config.getDouble("ElytraOldChunkSpeed") + 0.02)) {
                        evt.setCancelled(true);
                        evt.getPlayer().sendActionBar(ChatColor.RED + "Turn down your elytra settings, you are going WAY too fast.");
                        evt.getPlayer().playSound(evt.getPlayer().getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 1.0F, 1.0F);

                        if (config.getBoolean("SendClientInstructions")) {
                            evt.getPlayer().sendMessage(" ");
                            evt.getPlayer().sendMessage(ChatColor.GRAY + "Change your elytra hack settings to this");
                            evt.getPlayer().sendMessage(" ");
                            evt.getPlayer().sendMessage(ChatColor.RED + "Future settings: Speed " + Math.round((config.getDouble("ElytraOldChunkSpeed") * 10) * 100.0) / 100.0);
                            evt.getPlayer().sendMessage(ChatColor.BLUE + "KAMI BLUE settings: Speed " + Math.round(config.getDouble("ElytraOldChunkSpeed") * 100.0) / 100.0);
                            evt.getPlayer().sendMessage(" ");
                        }
                    } else {
                        if (config.getBoolean("ElytraActionBar")) {
                            if (evt.getPlayer().getLocale().startsWith("es")) {
                                evt.getPlayer().sendActionBar(ChatColor.GRAY + "Estás volando en" + ChatColor.GREEN + " ANTIGUO" + ChatColor.GRAY + " chunks. Velocidad: " + (String.format("%.2f", Math.min((double) Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY + config.getDouble("ElytraOldChunkSpeed")));
                            } else {
                                evt.getPlayer().sendActionBar(ChatColor.GRAY + "You are flying in" + ChatColor.GREEN + " OLD" + ChatColor.GRAY + " chunks. Speed: " + (String.format("%.2f", Math.min((double) Math.round(finalValue * 100.0D) / 100.0D, 20.0D)) + ChatColor.DARK_GRAY + " / " + ChatColor.GRAY + config.getDouble("ElytraOldChunkSpeed")));
                            }
                        }
                    }
                }
            }
        }
    }

    @EventHandler
    public void onChunkLoad(ChunkLoadEvent evt) {
        if (evt.isNewChunk()) {
            for (Player p : Bukkit.getOnlinePlayers()) {
                Point p1 = new Point(evt.getChunk().getX(), evt.getChunk().getZ());
                Point p2 = new Point(p.getLocation().getChunk().getX(), p.getLocation().getChunk().getZ());

                if (p1.distance(p2) < 100) {
                    playersinnewchunks.add(p.getName());
                    if (config.getBoolean("ChunksCommand")) {
                        newchunks.merge(p, 1, Integer::sum);
                        Bukkit.getScheduler().runTaskLater(this, () -> newchunks.merge(p, -1, Integer::sum), 20L);
                    }
                }
            }
        } else {
            for (Player p : Bukkit.getOnlinePlayers()) {
                Point p1 = new Point(evt.getChunk().getX(), evt.getChunk().getZ());
                Point p2 = new Point(p.getLocation().getChunk().getX(), p.getLocation().getChunk().getZ());

                if (p1.distance(p2) < 100) {
                    playersinnewchunks.remove(p.getName());
                    if (config.getBoolean("ChunksCommand")) {
                        oldchunks.merge(p, 1, Integer::sum);
                        Bukkit.getScheduler().runTaskLater(this, () -> oldchunks.merge(p, -1, Integer::sum), 20L);
                    }
                }
            }
        }
        if (config.getBoolean("RemoveSkullsOnChunkLoad")) {
            for (Entity e : evt.getChunk().getEntities()) {
                if (e.getType() == EntityType.WITHER_SKULL) {
                    e.remove();
                }
            }
        }
    }

    @EventHandler
    public void onKick(PlayerKickEvent event) {
        if (event.getReason().equalsIgnoreCase("Kicked for spamming")) {
            if (config.getBoolean("PreventSpamKick")) {
                event.setCancelled(true);
            } else {
                if (config.getBoolean("MaskKickMessages")) {
                    if (event.getPlayer().getLocale().startsWith("es")) {
                        event.setReason(ChatColor.GRAY + "Ha perdido la conexión con el servidor");
                    } else {
                        event.setReason(ChatColor.GRAY + "You have lost connection to the server");
                    }
                }
            }
        } else {
            if (config.getBoolean("MaskKickMessages")) {
                if (event.getPlayer().getLocale().startsWith("es")) {
                    event.setReason(ChatColor.GRAY + "Ha perdido la conexión con el servidor");
                } else {
                    event.setReason(ChatColor.GRAY + "You have lost connection to the server");
                }
            }
        }
    }

    @EventHandler
    private void onBlockDamage(BlockDamageEvent evt) {
        if (config.getBoolean("DEBUG")) {
            getLogger().info("BlockDamageEvent " + evt.getBlock().getType().toString());
        }

        if (config.getBoolean("AllowBreakingBedrock")) {
            if (evt.getBlock().getType() == Material.BEDROCK) {
                if (evt.getBlock().getWorld().getName().equalsIgnoreCase("world_nether")) {
                    if (evt.getBlock().getY() > 6 && evt.getBlock().getY() < 123) {
                        evt.getBlock().setType(Material.AIR);
                    }
                }

                if (evt.getBlock().getWorld().getName().equalsIgnoreCase("world")) {
                    if (evt.getBlock().getY() > 6) {
                        evt.getBlock().setType(Material.AIR);
                    }
                }

            }
        }
    }

    @EventHandler
    private void onChunkLoadEvent(ChunkLoadEvent evt) {
        if (config.getBoolean("RemoveALLIllegalBlocksOnCHUNKLOAD")) {
            Chunk c = evt.getChunk();

            if (!evt.isNewChunk()) {
                if (!c.getWorld().getName().equalsIgnoreCase("world_the_end")) {
                    int cx = c.getX() << 4;
                    int cz = c.getZ() << 4;
                    for (int x = cx; x < cx + 16; x++) {
                        for (int z = cz; z < cz + 16; z++) {
                            for (int y = 0; y < 128; y++) {

                                if ((config.getList("BANNED_BLOCKS").contains(c.getBlock(x, y, z).getType().toString()))) {
                                    if (y > 5) {
                                        if (evt.getChunk().getWorld().getName().equalsIgnoreCase("world_nether")) {
                                            if (y < 123) {
                                                c.getBlock(x, y, z).setType(Material.AIR);
                                                //getLogger().info("Found bedrock at " + x + " " + y + " " + z);
                                            }
                                        }
                                        if (evt.getChunk().getWorld().getName().equalsIgnoreCase("world")) {
                                            c.getBlock(x, y, z).setType(Material.AIR);
                                            //getLogger().info("Found bedrock at " + x + " " + y + " " + z);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (config.getBoolean("FillInBedrockFloor")) {
            Chunk c = evt.getChunk();
            if (!evt.isNewChunk()) {
                if (!c.getWorld().getName().equalsIgnoreCase("world_the_end")) {
                    int cx = c.getX() << 4;
                    int cz = c.getZ() << 4;
                    for (int x = cx; x < cx + 16; x++) {
                        for (int z = cz; z < cz + 16; z++) {
                            for (int y = 0; y < 128; y++) {
                                if (y == 0) {
                                    if (c.getBlock(x, y, z).getType() != Material.BEDROCK) {
                                        c.getBlock(x, y, z).setType(Material.BEDROCK);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (config.getBoolean("FillInBedrockRoof")) {
            Chunk c = evt.getChunk();
            if (!evt.isNewChunk()) {
                if (c.getWorld().getName().equalsIgnoreCase("world_nether")) {
                    int cx = c.getX() << 4;
                    int cz = c.getZ() << 4;
                    for (int x = cx; x < cx + 16; x++) {
                        for (int z = cz; z < cz + 16; z++) {
                            for (int y = 0; y < 128; y++) {
                                if (y == 127) {
                                    if (c.getBlock(x, y, z).getType() != Material.BEDROCK) {
                                        c.getBlock(x, y, z).setType(Material.BEDROCK);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    long lastGathered;

    @EventHandler
    public void onRedstoneEvent(BlockRedstoneEvent evt) {
        long now = Instant.now().toEpochMilli();
        double tps = Bukkit.getServer().getTPS()[0];
        if (tps < config.getDouble("Redstone")) {
            int current = evt.getOldCurrent();
            evt.setNewCurrent(current);
            if ((now - lastGathered) >= 30000) {
                lastGathered = now;
                getLogger().info("Disabled all redstone because tps is " + tps);
            }
        } else {
            int newcurrent = evt.getNewCurrent();
            evt.setNewCurrent(newcurrent);
            getLogger().info("Redstone at " + evt.getBlock().getLocation());
        }
    }

    @EventHandler
    private void onExplode(EntityExplodeEvent evt) {
        double tps = Bukkit.getServer().getTPS()[0];
        if (tps < config.getDouble("Explosions")) {
            evt.setCancelled(true);
        }
        if (config.getBoolean("DisableExplosions")) {
            evt.setCancelled(true);
        }
    }

    @EventHandler
    private void onExplodePrime(ExplosionPrimeEvent evt) {
        if (config.getBoolean("DisableExplosions")) {
            evt.setCancelled(true);
        }
    }

    @EventHandler
    private void onMove(PlayerMoveEvent evt) {
        if (config.getBoolean("BoatflyPatch")) {
            if (evt.getPlayer().isInsideVehicle()) {
                int x = evt.getPlayer().getLocation().getBlockX();
                int y = evt.getPlayer().getLocation().getBlockY();
                int z = evt.getPlayer().getLocation().getBlockZ();

                Location from = evt.getFrom();
                Location to = evt.getTo();
                double distY = to.getY() - from.getY();

                double distX = to.getX() - from.getX();
                double distZ = to.getZ() - from.getZ();
                double finalValue = Math.hypot(distX, distZ);

                // ik its a mess idgaf
                if ((evt.getPlayer().getWorld().getBlockAt(x, y - 1, z).getType() == Material.AIR) && evt.getPlayer().getWorld().getBlockAt(x, y - 2, z).getType() == Material.AIR && evt.getPlayer().getWorld().getBlockAt(x, y - 3, z).getType() == Material.AIR) {
                    if (distY != -0.439999999105936) {
                        if (evt.getPlayer().getVehicle() instanceof Boat) {
                            if (finalValue > 0.50 || distY > 0.0) {
                                evt.getPlayer().getVehicle().remove();
                                if (config.getBoolean("BoatflyMessage")) {
                                    if (evt.getPlayer().getLocale().startsWith("es")) {
                                        evt.getPlayer().sendMessage(ChatColor.GOLD + "Bote volar Deshabilitado debido a un exploit >:)");
                                    } else {
                                        evt.getPlayer().sendMessage(ChatColor.GOLD + "Boatfly disabled due to an exploit >:) If you aren't boat flying, boats on land are a little buggy.");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (config.getBoolean("DisableAllElytras")) {
            Player player = evt.getPlayer();
            PlayerInventory i = player.getInventory();
            Location l = i.getLocation();
            if (i.getChestplate() != null && i.getChestplate().getType().equals(Material.ELYTRA)) {
                ItemStack elytra = i.getChestplate();
                i.setChestplate(null);
                l.getWorld().dropItemNaturally(l, elytra);
                if (evt.getPlayer().getLocale().startsWith("es")) {
                    evt.getPlayer().sendMessage("Elytras desactivado debido a la explotación de LAG.");
                } else {
                    evt.getPlayer().sendMessage("Elytras disabled due to LAG exploit.");
                }
            }
        }
        if (config.getBoolean("PreventGoingBelowBedrockFloorOnElytra") || config.getBoolean("PreventGoingBelowBedrockFloor")) {
            if (evt.getPlayer().getLocation().getY() < 0) {
                if (!evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_the_end")) {
                    evt.getPlayer().getWorld().getBlockAt(evt.getPlayer().getLocation().getBlockX(), 0, evt.getPlayer().getLocation().getBlockZ()).setType(Material.BEDROCK);
                    evt.setTo(evt.getFrom().add(0, 2, 0));
                }
            }
        }
    }

    // dupes for 1b1t
    @EventHandler
    private void onPunch(EntityDamageByEntityEvent evt) {
        if (config.getBoolean("SlowDupe")) {
            if (evt.getEntityType() == EntityType.ITEM_FRAME) {
                double d = Math.random();
                // instanceof ShulkerBox wasnt working :/
                if ((((ItemFrame) evt.getEntity()).getItem().getType().toString().contains("SHULKER_BOX"))) {
                    if ((d * 10) > 9.99) {
                        evt.getEntity().getWorld().dropItemNaturally(evt.getEntity().getLocation(), ((ItemFrame) evt.getEntity()).getItem());
                        getLogger().info(evt.getDamager().getName() + " duped item");
                    }
                } else {
                    if (d > 0.99 && (d * 10) < 9.99) {
                        evt.getEntity().getWorld().dropItemNaturally(evt.getEntity().getLocation(), ((ItemFrame) evt.getEntity()).getItem());
                        getLogger().info(evt.getDamager().getName() + " duped item");
                    } else if ((d * 10) > 9.99) {
                        evt.getEntity().getWorld().dropItemNaturally(evt.getEntity().getLocation(), ((ItemFrame) evt.getEntity()).getItem().asQuantity(((ItemFrame) evt.getEntity()).getItem().getMaxStackSize()));
                        getLogger().info(evt.getDamager().getName() + " duped item");
                    }
                }
            }
        }
    }

    @EventHandler
    private void onInventoryInteractEvent(InventoryInteractEvent evt) {
        if (config.getBoolean("DEBUG")) {
            getLogger().info("InventoryInteractEvent ");
        }
        if (config.getBoolean("RemoveIllegalBlocksOnInteract")) {
            config.getList("BANNED_BLOCKS").forEach(b -> {
                if (evt.getInventory().contains(Material.getMaterial((String) b))) {
                    evt.getInventory().remove(Material.getMaterial((String) b));
                    evt.setCancelled(true);
                }
            });
        }
        if (config.getBoolean("RevertStackedItems")) {
            evt.getInventory().forEach(b -> {
                if (b != null) {
                    if (b.getAmount() > b.getMaxStackSize()) {
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }

    @EventHandler
    private void onInventoryClick(InventoryClickEvent evt) {
        if (config.getBoolean("RemoveIllegalBlocksOnClick")) {
            if (evt.getCurrentItem() != null) {
                String item = evt.getCurrentItem().getType().toString();

                if (config.getList("BANNED_BLOCKS").contains(item)) {
                    if (config.getBoolean("DEBUG")) {
                        getLogger().info("InventoryClickEvent " + item);
                    }
                    evt.getCurrentItem().setType(Material.getMaterial(config.getString("Replacement_Item")));
                    evt.setCancelled(true);
                }
            }
        }
        if (config.getBoolean("RevertStackedItems")) {
            evt.getWhoClicked().getInventory().forEach(b -> {
                if (b != null) {
                    if (b.getAmount() > b.getMaxStackSize()) {
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
            if (evt.getCurrentItem() != null) {
                if (evt.getCurrentItem().getAmount() > evt.getCurrentItem().getMaxStackSize()) {
                    evt.getCurrentItem().setAmount(evt.getCurrentItem().getMaxStackSize());
                }
            }
        }
    }

    @EventHandler
    private void onInventoryPickup(InventoryPickupItemEvent evt) {
        if (config.getBoolean("RemoveIllegalBlocksOnPickup")) {
            String item = evt.getItem().getType().toString();
            if (config.getBoolean("DEBUG")) {
                getLogger().info("InventoryPickupItemEvent " + item);
            }
            if (config.getList("BANNED_BLOCKS").contains(item)) {
                evt.setCancelled(true);
            }
        }
        if (config.getBoolean("RevertStackedItems")) {
            evt.getInventory().forEach(b -> {
                if (b != null) {
                    if (b.getAmount() > b.getMaxStackSize()) {
                        b.setAmount(b.getMaxStackSize());
                    }
                }
            });
        }
    }

    @EventHandler
    private void onInventoryMove(InventoryMoveItemEvent evt) {
        if (config.getBoolean("RemoveIllegalBlocksOnMove")) {
            String item = evt.getItem().getType().toString();
            if (config.getList("BANNED_BLOCKS").contains(item)) {
                if (config.getBoolean("DEBUG")) {
                    getLogger().info("InventoryMoveItemEvent " + item);
                }
                evt.getItem().setType(Material.getMaterial(config.getString("Replacement_Item")));
                evt.setCancelled(true);
            }
        }
        if (config.getBoolean("RevertStackedItems")) {
            if (evt.getItem() != null) {
                if (evt.getItem().getAmount() > evt.getItem().getMaxStackSize()) {
                    evt.getItem().setAmount(evt.getItem().getMaxStackSize());
                }
            }
        }
    }

    @EventHandler
    private void onBlockPlace(BlockPlaceEvent evt) {
        if (config.getBoolean("DEBUG")) {
            getLogger().info("BLOCKPLACED " + evt.getBlockPlaced());
            getLogger().info("BLOCK " + evt.getBlock());
            getLogger().info("BLOCKAGAINST " + evt.getBlockAgainst());
            getLogger().info("BlockReplacedState " + evt.getBlockReplacedState());
            getLogger().info("Hand " + evt.getHand());
            getLogger().info("ItemInHand " + evt.getItemInHand());
        }
        if (config.getBoolean("1b1tPlaceBedrock")) {
            if (evt.getBlockPlaced().getType().toString().equalsIgnoreCase("BEDROCK")) {
                if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_the_end")) {
                    evt.setCancelled(true);
                }
                if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world")) {
                    if (evt.getBlockPlaced().getY() < 10) {
                        evt.setCancelled(true);
                    }
                }
                if (evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_nether")) {
                    if (evt.getBlockPlaced().getY() < 10 || evt.getBlockPlaced().getY() > 122) {
                        evt.setCancelled(true);
                    }
                }
            }
        }
        if (config.getBoolean("PreventPlacingIllegalBlocks")) {
            String block = evt.getBlockPlaced().getType().toString();
            if (config.getList("BANNED_BLOCKS").contains(block)) {
                if (config.getBoolean("RemoveIllegalBlockOnPlace")) {
                    config.getList("BANNED_BLOCKS").forEach(b -> {
                        if (evt.getPlayer().getInventory().contains(Material.getMaterial((String) b))) {
                            evt.getPlayer().getInventory().remove(Material.getMaterial((String) b));
                            evt.setCancelled(true);
                        }
                    });
                }
                evt.setCancelled(true);
            }
            if (config.getBoolean("RevertStackedItems")) {
                evt.getPlayer().getInventory().forEach(b -> {
                    if (b != null) {
                        if (b.getAmount() > b.getMaxStackSize()) {
                            b.setAmount(b.getMaxStackSize());
                        }
                    }
                });
            }
        }
        if (config.getBoolean("PreventChunkBan")) {
            Chunk c = evt.getBlock().getChunk();
            Block b = evt.getBlock();
            if (b.getType() == Material.ENCHANTMENT_TABLE) {
                if (checkChunk(Material.ENCHANTMENT_TABLE, c) > config.getInt("MaxEnchantmentTablePerChunk")) {
                    if (evt.getPlayer().getLocale().startsWith("es")) {
                        evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de mesas de encantamiento / cofres de ender debido al lag.");
                    } else {
                        evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of enchantment tables/end chests due to lag.");
                    }
                    evt.setCancelled(true);
                }
            } else {
                if (b.getType() == Material.ENDER_CHEST) {
                    if (checkChunk(Material.ENDER_CHEST, c) > config.getInt("MaxEnderchestPerChunk")) {
                        if (evt.getPlayer().getLocale().startsWith("es")) {
                            evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de mesas de encantamiento / cofres de ender debido al lag.");
                        } else {
                            evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of enchantment tables/end chests due to lag.");
                        }
                        evt.setCancelled(true);
                    }
                }
                if (b.getState() instanceof Container) {
                    if (checkChunk(b.getType(), c) > config.getInt("MaxContainerPerChunk")) {
                        if (evt.getPlayer().getLocale().startsWith("es")) {
                            evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de almacenamiento containers debido al lag.");
                        } else {
                            evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of storage containers due to lag.");
                        }
                        evt.setCancelled(true);
                    }
                } else {
                    if (b.getType() == Material.WALL_SIGN || b.getType() == Material.SIGN_POST) {
                        if (checkChunk(b.getType(), c) > config.getInt("MaxSignPerChunk")) {
                            if (evt.getPlayer().getLocale().startsWith("es")) {
                                evt.getPlayer().sendMessage(ChatColor.GOLD + "Solo se le permite colocar una pequeña cantidad de letreros debido al lag");
                            } else {
                                evt.getPlayer().sendMessage(ChatColor.GOLD + "You are only allowed to place a small amount of signs due to lag.");
                            }
                            evt.setCancelled(true);
                        }
                    }
                }
            }
        }
    }


    @EventHandler
    private void onEntityTeleportEvent(EntityTeleportEvent evt) {
        if (config.getBoolean("PreventEndGatewayCrashExploit")) {
            if (evt.getEntity().getWorld().getName().equals("world_the_end") && !evt.getEntity().isEmpty()) {
                evt.setCancelled(true);
                if (!config.getBoolean("NoConsoleOutput")) {
                    getLogger().info("Prevented a entity " + "(" + evt.getEntity().getName() + ")" + " from going through end gateway at " + evt.getEntity().getLocation());
                }
            }
        }
    }

    @EventHandler
    private void onEntityChange(BlockPhysicsEvent evt) {
        double tps_double = Bukkit.getServer().getTPS()[0];
        if (tps_double < config.getDouble("FallingBlocks")) {
            evt.setCancelled(true);
        }
    }

    @EventHandler
    private void onEntityInteract(PlayerInteractAtEntityEvent evt) {
        if (config.getBoolean("DisableChestsOnDonkeys")) {
            if (evt.getRightClicked() instanceof ChestedHorse) {
                evt.setCancelled(true);
                (new BukkitRunnable() {
                    public void run() {
                        if (evt.getPlayer().getInventory().getItemInMainHand().getType() == Material.CHEST) {
                            ((ChestedHorse) evt.getRightClicked()).setCarryingChest(false);
                            //evt.getRightClicked().getWorld().dropItemNaturally(evt.getRightClicked().getLocation(), new ItemStack(Material.CHEST));
                        }
                        ((ChestedHorse) evt.getRightClicked()).setCarryingChest(false);
                    }
                }).runTaskLater(this, 2L);
            }
        }
    }


    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onCommandPreprocess(PlayerCommandPreprocessEvent evt) {
        String msg = evt.getMessage().toLowerCase();
        if (evt.getMessage().equalsIgnoreCase("/newchunks")) {
            getServer().getOnlinePlayers().forEach(b -> evt.getPlayer().sendMessage(b.getName() + ": " + newchunks.get(b)));
        }
        if (evt.getMessage().equalsIgnoreCase("/oldchunks")) {
            getServer().getOnlinePlayers().forEach(b -> evt.getPlayer().sendMessage(b.getName() + ": " + oldchunks.get(b)));
        }
        if (evt.getMessage().equalsIgnoreCase("/ignore")) {
            if (config.getBoolean("FixChatcoIgnoreBug")) {
                if (evt.getPlayer().getLocale().startsWith("es")) {
                    evt.getPlayer().sendMessage("§cNo agregaste un nombre de jugador....");
                } else {
                    evt.getPlayer().sendMessage("§cYou didn't add a player name....");
                }
                evt.setCancelled(true);
            }
        }
        if (config.getBoolean("FixWorldStatsCommandBug")) {
            if (evt.getMessage().equalsIgnoreCase("/stats")) {
                evt.getPlayer().performCommand("worldstats");
                evt.setCancelled(true);
            }
        }
        if (config.getBoolean("playercommand")) {
            if (evt.getMessage().equalsIgnoreCase("/geared")) {
                StringBuilder geared = new StringBuilder();
                StringBuilder newplayer = new StringBuilder();
                Integer geared_int = 0;
                Integer newplayer_int = 0;
                for (Player c : Bukkit.getServer().getOnlinePlayers()) {
                    if (c.getInventory().getChestplate() != null || c.getInventory().getBoots() != null || c.getInventory().getHelmet() != null || c.getInventory().getLeggings() != null) {
                        geared.append(c.getName()).append(", ");
                        geared_int++;
                    } else {
                        newplayer.append(c.getName()).append(", ");
                        newplayer_int++;
                    }
                }
                evt.getPlayer().sendMessage("Geared players: " + ChatColor.GOLD + geared + ChatColor.WHITE + " (" + geared_int + ")");
                evt.getPlayer().sendMessage("Naked players: " + ChatColor.GOLD + newplayer + ChatColor.WHITE + " (" + newplayer_int + ")");
                evt.getPlayer().sendMessage("Total players: " + ChatColor.GOLD + (newplayer_int + geared_int));
            }
        }
        if (config.getBoolean("playercommand")) {
            if (evt.getMessage().startsWith("/elytra")) {
                StringBuilder flying = new StringBuilder();
                StringBuilder notflying = new StringBuilder();
                Integer flyint = 0;
                Integer noflyint = 0;

                for (Player c : Bukkit.getServer().getOnlinePlayers()) {
                    if (c.isGliding()) {
                        flying.append(c.getName()).append(", ");
                        flyint++;
                    } else {
                        notflying.append(c.getName()).append(", ");
                        noflyint++;
                    }
                }

                evt.getPlayer().sendMessage("Flying on elytra: " + ChatColor.GOLD + flying + ChatColor.WHITE + " (" + flyint + ")");
                evt.getPlayer().sendMessage("Not flying on elytra: " + ChatColor.GOLD + notflying + ChatColor.WHITE + " (" + noflyint + ")");
                evt.getPlayer().sendMessage("Total players: " + ChatColor.GOLD + (flyint + noflyint));
            }
        }
        if (evt.getMessage().equalsIgnoreCase("/tps")) {
            if (config.getBoolean("UseSparkhealth")) {
                evt.getPlayer().performCommand("spark health");
                evt.setCancelled(true);
                Bukkit.getServer().getScheduler().runTaskLater(this, () -> {
                    if (evt.getPlayer().getLocale().startsWith("es")) {
                        evt.getPlayer().sendMessage(ChatColor.GRAY + "Este no es el tamaño mundial, para el tipo /stats de tamaño mundial");
                    } else {
                        evt.getPlayer().sendMessage(ChatColor.GRAY + "This is not the world size, for world size type /stats");
                    }
                }, 10L);
            }
        }
        if (evt.getMessage().toLowerCase().startsWith("/nick")) {
            if (config.getBoolean("nickresetonly")) {
                if (!evt.getMessage().equalsIgnoreCase("/nick off")) {
                    if (evt.getPlayer().getLocale().startsWith("es")) {
                        evt.getPlayer().sendMessage("§3No puedes cambiar tu nick pero puedes restablecerlo escribiendo /nick off si tienes un nick viejo!");
                    } else {
                        evt.getPlayer().sendMessage("§3You can't change your nick but you may reset it by typing /nick off if you have a legacy nick!");
                    }
                    evt.setCancelled(true);
                }
            }
        }
        if (evt.getMessage().toLowerCase().startsWith("/tpa ") || evt.getMessage().equalsIgnoreCase("/tpa") || evt.getMessage().toLowerCase().startsWith("/tpahere") || evt.getMessage().toLowerCase().startsWith("/call") || evt.getMessage().toLowerCase().startsWith("/ecall") || evt.getMessage().toLowerCase().startsWith("/etpa") || evt.getMessage().toLowerCase().startsWith("/tpask") || evt.getMessage().toLowerCase().startsWith("/etpask")) {
            if (config.getBoolean("5000blocksawaytoteleport")) {
                if (!evt.getPlayer().getWorld().getName().equalsIgnoreCase("world_the_end")) {
                    Point p1 = new Point(evt.getPlayer().getLocation().getBlockX(), evt.getPlayer().getLocation().getBlockZ());
                    Point p2 = new Point(0, 0);
                    if (p1.distance(p2) < 5000) {
                        if (evt.getPlayer().getLocale().startsWith("es")) {
                            evt.getPlayer().sendMessage("§3Necesitas ser 5000 cuadras de spawn para teletransportarse!");
                        } else {
                            evt.getPlayer().sendMessage("§3You need to be 5000 blocks away from spawn to teleport!");
                        }
                        evt.setCancelled(true);
                    }
                }
            }
        }
        if (config.getBoolean("AllowOPStobypass")) {
            if (!config.getList("CommandsWhitelisted").contains(msg.split(" ")[0])) {
                if (config.getBoolean("CommandWhitelist")) {
                    if (!evt.getPlayer().isOp()) {
                        if (evt.getPlayer().getLocale().startsWith("es")) {
                            evt.getPlayer().sendMessage("§4Mal comando. Tipo /help para todos los comandos.");
                        } else {
                            evt.getPlayer().sendMessage("§4Bad command. Type /help for all commands.");
                        }
                        evt.setCancelled(true);
                    }
                }
            }
        } else {
            if (!config.getList("CommandsWhitelisted").contains(msg.split(" ")[0])) {
                if (config.getBoolean("CommandWhitelist")) {
                    if (evt.getPlayer().getLocale().startsWith("es")) {
                        evt.getPlayer().sendMessage("§4Mal comando. Tipo /help para todos los comandos.");
                    } else {
                        evt.getPlayer().sendMessage("§4Bad command. Type /help for all commands.");
                    }

                    evt.setCancelled(true);
                }
            }
        }

    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        if (config.getBoolean("PreventGodMode")) {
            injectPlayer(event.getPlayer());
            a.put(event.getPlayer(), 0);
            b.put(event.getPlayer(), 0);
        }
        if (config.getBoolean("DisableNCPGeyser")) {
            String ip = event.getPlayer().getAddress().toString().replace("/", "").replaceAll(":(.*)", "");
            if (ip.contains("127.0.0.1")) {
                getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(), "pex user " + event.getPlayer().getName() + " add nocheatplus.shortcut.bypass");
            }
        }
    }

    @EventHandler
    public void onLogin(PlayerLoginEvent evt) {
        if (config.getBoolean("BypassSlots")) {
            if (evt.getResult() == PlayerLoginEvent.Result.KICK_FULL) {
                evt.allow();
            }
        }
    }

    @EventHandler
    public void onLeave(PlayerQuitEvent event) {
        if (config.getBoolean("PreventGodMode")) {
            removePlayer(event.getPlayer());
            a.put(event.getPlayer(), 0);
            b.put(event.getPlayer(), 0);
        }
        if (config.getBoolean("DisableNCPGeyser")) {
            String ip = event.getPlayer().getAddress().toString().replace("/", "").replaceAll(":(.*)", "");
            if (ip.contains("127.0.0.1")) {
                getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(), "pex user " + event.getPlayer().getName() + " remove nocheatplus.shortcut.bypass");
            }
        }
    }

//    HashSet<String> whitelisted = new HashSet<>();
//    HashMap<String, Double> speeds = new HashMap<>();
//    @EventHandler
//    public void onMoveAC(PlayerMoveEvent evt){
//        if(config.getBoolean("GeyserFlyPatch")){
//            if(evt.getPlayer().getName().contains("moom0o")){
//                if(!evt.getPlayer().isGliding()){
//                    Location from = evt.getFrom();
//                    Location to = evt.getTo();
//                    double distX = to.getX() - from.getX();
//                    double distZ = to.getZ() - from.getZ();
//                    double distY = to.getY() - from.getY();
//                    double finalValue = Math.hypot(distX, distZ);
//                    Integer x = to.getBlockX();
//                    Integer y = to.getBlockY();
//                    Integer z = to.getBlockZ();
//                    Integer xx = from.getBlockX();
//                    Integer yy = from.getBlockY();
//                    Integer zz = from.getBlockZ();
//                    Integer xxx = evt.getPlayer().getLocation().getBlockX();
//                    Integer yyy = evt.getPlayer().getLocation().getBlockY();
//                    Integer zzz = evt.getPlayer().getLocation().getBlockZ();
//                    speeds.put(evt.getPlayer().getName(), finalValue);
//                    evt.getPlayer().sendMessage("FROM: " + evt.getPlayer().getWorld().getBlockAt(xx, yy-1, zz).getType());
//                    evt.getPlayer().sendMessage("TO: " + evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType());
//
//                    if((evt.getPlayer().getWorld().getBlockAt(xx, yy-1, zz).getType() != Material.AIR && evt.getPlayer().getWorld().getBlockAt(xx, yy-2, zz).getType() != Material.AIR)){
//                        if(evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType() == Material.AIR){
//                            evt.getPlayer().sendMessage("WHITELISTED");
//                            whitelisted.add(evt.getPlayer().getName());
//                            Bukkit.getServer().getScheduler().runTaskLater(this, () -> {
//                                whitelisted.remove(evt.getPlayer().getName());
//                                evt.getPlayer().sendMessage("UNWHITELISTED");
//
//                            }, 1 * 20L);
//                        }
//                    }
//                    if(!whitelisted.contains(evt.getPlayer().getName())){
//                        if((evt.getPlayer().getWorld().getBlockAt(xx, yy-1, zz).getType() == Material.AIR && evt.getPlayer().getWorld().getBlockAt(xx, yy-2, zz).getType() == Material.AIR)){
//                            if(evt.getPlayer().getWorld().getBlockAt(x, y-1, z).getType() == Material.AIR && evt.getPlayer().getWorld().getBlockAt(x, y-2, z).getType() == Material.AIR){
//                                if(distY > -0.02442408821369213){
//                                    evt.setCancelled(true);
//
//                                }
//                            }
//                        }
//                    }
//                }
//            }
//
//        }
//    }

    @EventHandler
    public void onMoveevt(PlayerMoveEvent event) {
        if (config.getBoolean("PreventGodMode")) {
            if (event.getPlayer().getVehicle() != null) {
                a.put(event.getPlayer(), 1);
                if (b.get(event.getPlayer()) != null) {
                    if (b.get(event.getPlayer()) > 3) {
                        Bukkit.getServer().getConsoleSender().sendMessage(ChatColor.RED + "" + event.getPlayer() + " tried getting into godmode");
                        event.getPlayer().leaveVehicle();
                        a.put(event.getPlayer(), 0);
                        b.put(event.getPlayer(), 0);
                    }
                }
            }
        }
    }

    @EventHandler
    private void onChat(AsyncPlayerChatEvent event) {
        if (antispam.contains(event.getPlayer().getName())) {
            event.setCancelled(true);
            getLogger().info(event.getPlayer().getName() + " FAILED to send message due to slowmode: " + event.getMessage());
        } else {
            antispam.add(event.getPlayer().getName());
            Bukkit.getServer().getScheduler().runTaskLater(this, () -> antispam.remove(event.getPlayer().getName()), config.getInt("AntiSpamTime") * 20L);
        }
        if (words.contains(event.getMessage())) {
            event.setCancelled(true);
            getLogger().info(event.getPlayer().getName() + " FAILED to send message due to duplicate message: " + event.getMessage());

        } else {
            if (event.getMessage().length() > 10) {
                words.add(event.getMessage());
                Bukkit.getServer().getScheduler().runTaskLater(this, () -> words.remove(event.getMessage()), config.getInt("AntiSpamWordTime") * 20L);
            }
        }
        if (config.getBoolean("Replace@")) {
            if (event.getMessage().contains("@")) {
                event.setMessage(event.getMessage().replaceAll("@", ""));
                event.getPlayer().sendMessage("stop trying to ping me faggot");
            }
        }
        if (config.getBoolean("Preventlinks")) {
            /*
             code from John200410
            */
            final World playerWorld = event.getPlayer().getWorld();

            //check if player is in overworld
            if (!playerWorld.getName().equals("world")) {
                return;
            }
            final Location location = event.getPlayer().getLocation();

            //check distance from the world spawn
            if (location.distance(playerWorld.getSpawnLocation()) > 1000) {
                return;
            }

            //check if message contains a link
            final String msg = event.getMessage();

            //loop through each word
            for (String string : msg.split(" ")) {
                //check if it is a link
                if (string.matches(REGEX_CHECK) || string.matches(HTTP_REGEX_CHECK)) {
                    if (!(event.getPlayer().getName().equals("moooomoooo"))) {
                        getLogger().info(event.getPlayer().getName());
                        getLogger().info("Prevented " + event.getPlayer().getName() + " from sending " + event.getMessage() + " because link");
                        event.setCancelled(true);
                    }
                }
            }
        }
    }

    private void removePlayer(Player player) {
        Channel channel = ((CraftPlayer) player).getHandle().playerConnection.networkManager.channel;
        channel.eventLoop().submit(() -> {
            channel.pipeline().remove(player.getName());
            return null;
        });
    }

    private void injectPlayer(Player player) {
        ChannelDuplexHandler channelDuplexHandler = new ChannelDuplexHandler() {

            @Override
            public void channelRead(ChannelHandlerContext channelHandlerContext, Object packet) throws Exception {
                if ((packet instanceof PacketPlayInFlying.PacketPlayInPosition || packet instanceof PacketPlayInFlying.PacketPlayInPositionLook) && a.get(player) > 0) {
                    int count = b.getOrDefault(player, 0);
                    b.put(player, count + 1);
                    a.put(player, 0);
                }
                super.channelRead(channelHandlerContext, packet);
            }

            @Override
            public void write(ChannelHandlerContext channelHandlerContext, Object packet, ChannelPromise channelPromise) throws Exception {
                super.write(channelHandlerContext, packet, channelPromise);
            }

        };

        ChannelPipeline pipeline = ((CraftPlayer) player).getHandle().playerConnection.networkManager.channel.pipeline();
        pipeline.addBefore("packet_handler", player.getName(), channelDuplexHandler);
    }

    Integer checkChunk(Material material, Chunk c) {
        int count = 0;
        int cx = c.getX() << 4;
        int cz = c.getZ() << 4;

        for (int x = cx; x < cx + 16; x++) {
            for (int z = cz; z < cz + 16; z++) {
                for (int y = 0; y < 128; y++) {
                    if (c.getBlock(x, y, z).getType() == material) {
                        count++;
                    }
                }
            }
        }

        return count;
    }

    void broadcastOp(String s) {
        Bukkit.getOnlinePlayers().forEach(b -> {
            if (b.isOp()) {
                b.sendMessage(s);
            }
        });

        getLogger().info(s);
    }
}
