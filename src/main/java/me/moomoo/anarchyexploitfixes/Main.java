package me.moomoo.anarchyexploitfixes;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketEvent;
import me.moomoo.anarchyexploitfixes.misc.*;
import me.moomoo.anarchyexploitfixes.patches.*;
import me.moomoo.anarchyexploitfixes.prevention.*;
import org.bukkit.*;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;

import java.awt.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.logging.Logger;

public class Main extends JavaPlugin implements Listener {
    public static final Integer[] old_total = {0};
    public static final Integer[] new_total = {0};
    public final HashMap<Player, Integer> newChunks = new HashMap<>();
    public final HashMap<Player, Integer> oldChunks = new HashMap<>();
    public HashSet<String> crafting = new HashSet<>();
    public HashMap<Player, Integer> levels = new HashMap<>();
    public HashMap<Player, Integer> boatLevels = new HashMap<>();
    public FileConfiguration config = getConfig();
    public ProtocolManager protocolManager;
    private Logger log;

    @Override
    public void onEnable() {
        log = getLogger();
        PluginManager pm = getServer().getPluginManager();
        // Disable some config options for non 1.12 servers because they cause a shit ton of errors
        if (!config.getBoolean("OverideConfigChanges")) {
            if (!Bukkit.getVersion().contains("1.12")) {
                getConfig().set("RemoveALLIllegalBlocksOnCHUNKLOAD", false);
                getConfig().set("FillInBedrockFloor", false);
                getConfig().set("FillInBedrockRoof", false);
                saveConfig();
                log.warning("Disabled:\nRemoveALLIllegalBlocksOnCHUNKLOAD\nFillInBedrockFloor\nFillInBedrockRoof\nDue to errors with non 1.12.2 versions.");
            }
        }
        log.info("Registering events");
        // please make a pull request if there is a better way to do this
        pm.registerEvents(this, this);
        pm.registerEvents(new DupeFixes(this), this);
        pm.registerEvents(new DisableWithers(this), this);
        pm.registerEvents(new Elytra(this), this);
        pm.registerEvents(new EndPortalPatch(this), this);
        pm.registerEvents(new Bedrock(this), this);
        pm.registerEvents(new Boats(this), this);
        pm.registerEvents(new Chat(this), this);
        pm.registerEvents(new ChunkBan(this), this);
        pm.registerEvents(new CommandPreProcess(this), this);
        pm.registerEvents(new CrashExploits(this), this);
        pm.registerEvents(new Illegals(this), this);
        pm.registerEvents(new JoinMessages(this), this);
        pm.registerEvents(new Kicks(this), this);
        pm.registerEvents(new LagExploits(this), this);
        pm.registerEvents(new MyServer(this), this);
        pm.registerEvents(new NetherRoof(this), this);
        pm.registerEvents(new Redstone(this), this);
        pm.registerEvents(new NetherPortals(this), this);
        pm.registerEvents(new GodMode(this), this);
        pm.registerEvents(new RenderDistance(this), this);
        pm.registerEvents(new CommandExploits(this), this);
        if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
            // I would put this in a seperate class if I could however I cba to deal with the annoying ass static errors.
            getLogger().info("Detected ProtocolLib!");
            protocolManager = ProtocolLibrary.getProtocolManager();
            if (config.getBoolean("PreventCraftingRecipeLagExploit")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.NORMAL, PacketType.Play.Client.AUTO_RECIPE) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                if (event.getPacketType() == PacketType.Play.Client.AUTO_RECIPE) {
                                    if (crafting.contains(event.getPlayer().getName())) {
                                        event.setCancelled(true);

                                    } else {
                                        crafting.add(event.getPlayer().getName());
                                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> crafting.remove(event.getPlayer().getName()), 1L);
                                    }
                                }
                            }
                        });
            }
            if (config.getBoolean("PreventPacketFly")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.HIGHEST, PacketType.Play.Client.TELEPORT_ACCEPT) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                Player e = event.getPlayer();
                                Location l = event.getPlayer().getLocation();
                                if (event.getPlayer().getWorld().getBlockAt(l.getBlockX(), l.getBlockY() - 1, l.getBlockZ()).getType() == Material.AIR && !e.isGliding() && !e.isInsideVehicle()) {
                                    if (event.getPacketType() == PacketType.Play.Client.TELEPORT_ACCEPT) {
                                        if (levels.get(e) != null) {
                                            if (levels.get(e) > getConfig().getInt("MaxTeleportPacketsPer10Seconds")) {
                                                event.setCancelled(true);
                                                if (getConfig().getBoolean("LogPacketFlyEvents")) {
                                                    getLogger().warning(e.getName() + " prevented from packetflying");
                                                }
                                            } else {
                                                levels.merge(e, 1, Integer::sum);
                                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e, levels.get(e) - 1), 200L);
                                            }
                                        } else {
                                            levels.put(e, 1);
                                            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> levels.put(e, levels.get(e) - 1), 200L);
                                        }
                                    }
                                }
                            }
                        });
            }
            if (config.getBoolean("BoatflyPatch")) {
                protocolManager.addPacketListener(
                        new PacketAdapter(this, ListenerPriority.HIGHEST, PacketType.Play.Client.USE_ENTITY) {
                            @Override
                            public void onPacketReceiving(PacketEvent event) {
                                Player e = event.getPlayer();
                                if (e.isInsideVehicle() && e.getVehicle().getType() == EntityType.BOAT) {
                                    if (event.getPacketType() == PacketType.Play.Client.USE_ENTITY) {
                                        if (boatLevels.get(e) != null) {
                                            if (boatLevels.get(e) > getConfig().getInt("MaxEntityPacketsPer10Seconds")) {
                                                e.getVehicle().remove();
                                                if (getConfig().getBoolean("LogBoatFlyEvents")) {
                                                    getLogger().warning(e.getName() + " prevented from boatflying");
                                                }
                                            } else {
                                                boatLevels.merge(e, 1, Integer::sum);
                                                Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e, boatLevels.get(e) - 1), 200L);
                                            }
                                        } else {
                                            boatLevels.put(e, 1);
                                            Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> boatLevels.put(e, boatLevels.get(e) - 1), 200L);
                                        }
                                    }
                                }
                            }
                        });
            }
        } else {
            getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
        }
        log.info("Registering events finished");
        log.info("Registering commands");
        getCommand("aef").setExecutor(new Commands(this));
        if (config.getBoolean("StrictIllegalPrevention")) {
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> e.getInventory().forEach(this::revert))), 0L, 20L);
        }
        if (config.getBoolean("RemoveAllWitherSkulls")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Entity e : w.getEntities()) {
                        if (e.getType() == EntityType.WITHER_SKULL) {
                            e.remove();
                        }
                    }
                }
            }, 0L, 20L);
        }
        if (config.getBoolean("ExperimentalDupePatch2")) {
            Bukkit.getScheduler().runTaskTimer(this, this::preventDespawning, 0L, 20L);
        }
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            new_total[0] = 0;
            old_total[0] = 0;
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (newChunks.get(b) != null) {
                    new_total[0] = new_total[0] + newChunks.get(b);
                }
            });
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (oldChunks.get(b) != null) {
                    old_total[0] = old_total[0] + oldChunks.get(b);
                }
            });
        }, 0L, 20L);

        if (config.getBoolean("RateLimitLevers"))
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, Redstone::clearLeverHashmap, 0, config.getInt("RateLimitTime"));

        saveDefaultConfig();

        log.info("[ENABLED] AnarchyExploitFixes - Made by moomoo");

        new Metrics(this, 8700);
    }

    public void onDisable() {
        log.info("[DISABLED] AnarchyExploitFixes - Made by moomoo");
    }

    public Integer checkChunk(Material material, Chunk c) {
        int count = 0;
        int cx = c.getX() << 4;
        int cz = c.getZ() << 4;

        for (int x = cx; x < cx + 16; x++) {
            for (int z = cz; z < cz + 16; z++) {
                for (int y = 0; y < 256; y++) {
                    if (c.getBlock(x, y, z).getType() == material) {
                        count++;
                    }
                }
            }
        }

        return count;
    }

    public void revert(ItemStack c) {
        if (c != null) {
            if (config.getBoolean("RevertStackedItems")) {
                if (config.getBoolean("OnlyRevertStacksForCertainItems")) {
                    for (String s : config.getStringList("RevertStackedItemsList")) {
                        if (c.getType().name().equals(s)) {
                            if (c.getAmount() > c.getMaxStackSize()) {
                                c.setAmount(c.getMaxStackSize());
                            }
                        }
                    }
                } else {
                    if (c.getAmount() > c.getMaxStackSize()) {
                        c.setAmount(c.getMaxStackSize());
                    }
                }
            }
            if (config.getBoolean("RevertEnchantments")) {
                for (Map.Entry<Enchantment, Integer> e : c.getEnchantments().entrySet()) {
                    if (e.getValue() != null && e.getKey() != null) {
                        if (e.getValue() > e.getKey().getMaxLevel()) {
                            c.subtract();
                        }
                    }
                }
            }
            if (config.getList("BANNED_BLOCKS").contains(c.getType().name())) {
                c.subtract();
            }
        }
    }

    public void preventDespawning() {
        for (World w : Bukkit.getWorlds()) {
            for (Entity e : w.getEntities()) {
                if (e instanceof LivingEntity) {
                    ((LivingEntity) e).setRemoveWhenFarAway(!isEntityCloseToPlayer(e));
                }
            }
        }
    }

    public boolean isEntityCloseToPlayer(Entity e) {
        for (Player p : Bukkit.getOnlinePlayers()) {
            Point p1 = new Point(p.getLocation().getBlockX(), p.getLocation().getBlockZ());
            Point p2 = new Point(e.getLocation().getBlockX(), e.getLocation().getBlockZ());
            if (p1.distance(p2) < 500) {
                return true;
            }
        }
        return false;
    }
}
