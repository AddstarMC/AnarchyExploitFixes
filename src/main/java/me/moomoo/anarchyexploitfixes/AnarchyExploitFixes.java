package me.moomoo.anarchyexploitfixes;

import me.moomoo.anarchyexploitfixes.aefcommands.AEFCmd;
import me.moomoo.anarchyexploitfixes.aefcommands.ConnectionMsgsCmd;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.config.LanguageCache;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.modules.oldcode.prevention.*;
import org.bstats.bukkit.Metrics;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.*;
import org.bukkit.event.Listener;
import org.bukkit.plugin.java.JavaPlugin;
import org.reflections.Reflections;
import org.reflections.scanners.Scanners;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.bukkit.Bukkit.getPluginManager;

public class AnarchyExploitFixes extends JavaPlugin implements Listener {
    private static AnarchyExploitFixes instance;
    private static Config config;
    private static HashMap<String, LanguageCache> languageCacheMap;
    public static final Integer[] oldTotal = {0};
    public static final Integer[] newTotal = {0};
    public final Map<UUID, Integer> newChunks = new HashMap<>();
    public final Map<UUID, Integer> oldChunks = new HashMap<>();
    public final Set<String> playersInNewChunks = new HashSet<>();
    public final Set<String> connectionMsgs = new HashSet<>();
    public double tps = 20.0;

    @Override
    public void onEnable() {
        instance = this;

        reloadLang();
        reloadAEFConfig();
        getCommand("aef").setExecutor(new AEFCmd());
        getCommand("toggleconnectionmsgs").setExecutor(new ConnectionMsgsCmd());

        Logger log = getLogger();

        if (config.protocolLib_IsDisabled) {
            log.warning("You specified to disable all ProtocolLib patches.");
        } else {
            if (!getPluginManager().isPluginEnabled("ProtocolLib")) {
                log.severe("Could not find ProtocolLib. Many gamebreaking exploits will not be patched. Download at https://www.spigotmc.org/resources/protocollib.1997/");
            }
        }

        ScheduledExecutorService schedulerTPS = Executors.newScheduledThreadPool(1);
        schedulerTPS.scheduleAtFixedRate(() -> {
            Thread thread = new Thread(() -> tps = getServer().getTPS()[0]);
            thread.start();
        }, 1, 1, TimeUnit.SECONDS);

        Bukkit.getScheduler().runTaskTimer(this, () -> {
            newTotal[0] = 0;
            oldTotal[0] = 0;
            Bukkit.getOnlinePlayers().forEach(player -> {
                if (newChunks.get(player.getUniqueId()) != null) {
                    newTotal[0] = newTotal[0] + newChunks.get(player.getUniqueId());
                }
            });
            Bukkit.getOnlinePlayers().forEach(player -> {
                if (oldChunks.get(player.getUniqueId()) != null) {
                    oldTotal[0] = oldTotal[0] + oldChunks.get(player.getUniqueId());
                }
            });
        }, 0L, 20L);

        if (getConfig().getBoolean("RateLimitLevers"))
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, Redstone::clearLeverHashmap, 0, getConfig().getInt("RateLimitTime"));

        saveDefaultConfig();
        // Disable some config options for non 1.12 servers because they cause a shit ton of errors
        if (!getConfig().getBoolean("OverideConfigChanges")) {
            if (!Bukkit.getVersion().contains("1.12")) {
                getConfig().set("RemoveALLIllegalBlocksOnCHUNKLOAD", false);
                getConfig().set("ExperimentalDupePatch2", false);
                log.warning("Disabled:\nRemoveALLIllegalBlocksOnCHUNKLOAD\nFillInBedrockFloor\nFillInBedrockRoof\nExperimentalDupePatch2\nDue to errors with non 1.12.2 versions.");
            } else {
                getConfig().set("DisableFish", false);
                getConfig().set("AllowSlabsInBurrow", false);

                log.warning("Disabled:\nDisableFish\nAllowSlabsInBurrow\nbecause server is 1.12");
            }
        }

        log.info("[ENABLED] AnarchyExploitFixes - Made by moomoo");

        new Metrics(this, 8700);
    }

    private void register(Listener... list) {
        getServer().getPluginManager().registerEvents(this, this);
        for (Listener listener : list) {
            if (getConfig().getStringList("DisabledClasses").contains(listener.getClass().getSimpleName())) {
                getLogger().warning("Skipped loading class " + listener.getClass().getSimpleName() + " because disabled in config.");
            } else {
                getServer().getPluginManager().registerEvents(listener, this);
                getLogger().info("Loaded class " + listener.getClass().getSimpleName());
            }
        }
    }

    public static LanguageCache getLang(String lang) {
        lang = lang.replace("-", "_");
        if (config.auto_lang) {
            return languageCacheMap.getOrDefault(lang, languageCacheMap.get(config.default_lang.toString().toLowerCase()));
        } else {
            return languageCacheMap.get(config.default_lang.toString().toLowerCase());
        }
    }

    public static LanguageCache getLang(Locale locale) {
        return getLang(locale.toString().toLowerCase());
    }

    public static LanguageCache getLang(CommandSender commandSender) {
        if (commandSender instanceof Player) {
            Player player = (Player) commandSender;
            return getLang(player.getLocale());
        } else {
            return getLang(config.default_lang);
        }
    }

    public void reloadAEFConfig() {
        config = new Config();
        AnarchyExploitFixesModule.reloadModules();
        config.saveConfig();
    }

    public void reloadLang() {
        languageCacheMap = new HashMap<>();
        try {
            File langDirectory = new File(instance.getDataFolder() + File.separator + "lang");
            Files.createDirectories(langDirectory.toPath());
            for (String fileName : getDefaultLanguageFiles()) {
                String localeString = fileName.substring(fileName.lastIndexOf('/') + 1, fileName.lastIndexOf('.'));
                getLogger().info(String.format("Found language file for %s", localeString));
                LanguageCache langCache = new LanguageCache(localeString);
                languageCacheMap.put(localeString, langCache);
            }
            Pattern langPattern = Pattern.compile("([a-z]{1,3}_[a-z]{1,3})(\\.yml)", Pattern.CASE_INSENSITIVE);
            for (File langFile : langDirectory.listFiles()) {
                Matcher langMatcher = langPattern.matcher(langFile.getName());
                if (langMatcher.find()) {
                    String localeString = langMatcher.group(1).toLowerCase();
                    if(!languageCacheMap.containsKey(localeString)) { // make sure it wasn't a default file that we already loaded
                        getLogger().info(String.format("Found language file for %s", localeString));
                        LanguageCache langCache = new LanguageCache(localeString);
                        languageCacheMap.put(localeString, langCache);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
            getLogger().severe("Error loading language files! Language files will not reload to avoid errors, make sure to correct this before restarting the server!");
        }
    }

    private Set<String> getDefaultLanguageFiles(){
        Reflections reflections = new Reflections("lang", Scanners.Resources);
        return reflections.getResources(Pattern.compile("([a-z]{1,3}_[a-z]{1,3})(\\.yml)"));
    }

    public static AnarchyExploitFixes getInstance()  {
        return instance;
    }

    public static Config getConfiguration() {
        return config;
    }
}
