package me.moomoo.anarchyexploitfixes;

import me.moomoo.anarchyexploitfixes.aefcommands.AEFCmd;
import me.moomoo.anarchyexploitfixes.aefcommands.ConnectionMsgsCmd;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.config.LanguageCache;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.modules.oldcode.patches.*;
import me.moomoo.anarchyexploitfixes.modules.oldcode.prevention.*;
import me.moomoo.anarchyexploitfixes.utils.ItemUtils;
import org.bstats.bukkit.Metrics;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.ShulkerBox;
import org.bukkit.command.CommandSender;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.*;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.SkullMeta;
import org.bukkit.plugin.java.JavaPlugin;
import org.reflections.Reflections;
import org.reflections.scanners.Scanners;

import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AnarchyExploitFixes extends JavaPlugin implements Listener {
    private static AnarchyExploitFixes instance;
    private static Config configCache;
    private static HashMap<String, LanguageCache> languageCacheMap;
    public static final Integer[] oldTotal = {0};
    public static final Integer[] newTotal = {0};
    public final Map<UUID, Integer> newChunks = new HashMap<>();
    public final Map<UUID, Integer> oldChunks = new HashMap<>();
    public final Set<String> playersInNewChunks = new HashSet<>();
    public final Set<String> connectionMsgs = new HashSet<>();
    public double tps = 20.0;

    public void replaceEnchantment(ItemStack item, Enchantment enchantment, Integer level) {
        item.removeEnchantment(enchantment);

        if (enchantment.canEnchantItem(item)) {
            item.addEnchantment(enchantment, level);
        } else {
            if (!getConfig().getBoolean("RevertUnEnchantable"))
                item.addUnsafeEnchantment(enchantment, level);
        }
    }

    @Override
    public void onEnable() {
        instance = this;

        reloadLang();
        reloadAEFConfig();
        getCommand("aef").setExecutor(new AEFCmd());
        getCommand("toggleconnectionmsgs").setExecutor(new ConnectionMsgsCmd());

        Logger log = getLogger();

        if (getConfig().getBoolean("DisableAllProtocolLib")) {
            log.info("You specified to disable all ProtocolLib patches.");
        } else {
            if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
                log.info("Detected ProtocolLib!");
                ProtocolLib.protocolLibWrapper(this);
            } else {
                getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
                Bukkit.getScheduler().runTaskTimer(this, () -> getLogger().warning("ProtocolLib plugin not detected, many gamebreaking exploits will not be patched. Download at https://www.spigotmc.org/resources/protocollib.1997/"), 200L, 1200L);
            }
        }

        if (getConfig().getBoolean("StrictIllegalPrevention")) {
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(world -> world.getPlayers().forEach(player -> player.getInventory().forEach(this::revert))), 0L, 20L);
        }

        if (getConfig().getBoolean("RemoveAllWitherSkulls")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World world : Bukkit.getWorlds()) {
                    for (Entity entity : world.getEntities()) {
                        if (entity.getType().equals(EntityType.WITHER_SKULL)) {
                            entity.remove();
                        }
                    }
                }
            }, 0L, 20L);
        }

        ScheduledExecutorService schedulerTPS = Executors.newScheduledThreadPool(1);
        schedulerTPS.scheduleAtFixedRate(() -> {
            Thread thread = new Thread(() -> tps = getServer().getTPS()[0]);
            thread.start();
        }, 1, 1, TimeUnit.SECONDS);

        if (getConfig().getBoolean("PreventTooManyEntitiesInChunk")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (ItemUtils.isEntity(entity) && !(entity instanceof LivingEntity)) {
                                if (count > getConfig().getInt("MaxEntitiesInChunk")) {
                                    entity.remove();
                                    if (getConfig().getBoolean("LogEntityRemovals")) {
                                        getLogger().warning("Removed entity " + entity.getType() + " at " + entity.getLocation() + " because reached entity limit of " + getConfig().getInt("MaxEntitiesInChunk"));
                                    }
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, getConfig().getInt("EntityCheckTimeTicks"));
        }

        if (getConfig().getBoolean("StrictVehicleCheck")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof Vehicle) {
                                if (count > getConfig().getInt("MaxVehiclesInChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 200L);
        }

        Bukkit.getScheduler().runTaskTimer(this, () -> {
            newTotal[0] = 0;
            oldTotal[0] = 0;
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (newChunks.get(b.getUniqueId()) != null) {
                    newTotal[0] = newTotal[0] + newChunks.get(b.getUniqueId());
                }
            });
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (oldChunks.get(b.getUniqueId()) != null) {
                    oldTotal[0] = oldTotal[0] + oldChunks.get(b.getUniqueId());
                }
            });
        }, 0L, 20L);

        if (getConfig().getBoolean("RateLimitLevers"))
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, Redstone::clearLeverHashmap, 0, getConfig().getInt("RateLimitTime"));

        saveDefaultConfig();
        // Disable some config options for non 1.12 servers because they cause a shit ton of errors
        if (!getConfig().getBoolean("OverideConfigChanges")) {
            if (!Bukkit.getVersion().contains("1.12")) {
                getConfig().set("RemoveALLIllegalBlocksOnCHUNKLOAD", false);
                getConfig().set("FillInBedrockFloor", false);
                getConfig().set("FillInBedrockRoof", false);
                getConfig().set("ExperimentalDupePatch2", false);
                log.warning("Disabled:\nRemoveALLIllegalBlocksOnCHUNKLOAD\nFillInBedrockFloor\nFillInBedrockRoof\nExperimentalDupePatch2\nDue to errors with non 1.12.2 versions.");
            } else {
                getConfig().set("DisableFish", false);
                getConfig().set("AllowSlabsInBurrow", false);

                log.warning("Disabled:\nDisableFish\nAllowSlabsInBurrow\nbecause server is 1.12");
            }
        }
        if (getConfig().getBoolean("ExperimentalDupePatch2")) {
            Bukkit.getScheduler().runTaskTimer(this, this::preventDespawning, 0L, 20L);
        }
        log.info("[ENABLED] AnarchyExploitFixes - Made by moomoo");

        new Metrics(this, 8700);
    }

    public Integer checkChunk(Material material, Chunk c) {
        if (Bukkit.getVersion().contains("1.12") || getConfig().getBoolean("OverideConfigChanges")) {
            int count = 0;
            int cx = c.getX() << 4;
            int cz = c.getZ() << 4;

            for (int x = cx; x < cx + 16; x++) {
                for (int z = cz; z < cz + 16; z++) {
                    for (int y = 0; y < 256; y++) {
                        if (c.getBlock(x, y, z).getType() == material) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        return 0;
    }

    public void revert(ItemStack item) {
        if (item != null) {
            // Warning: Enables a dupe exploit, reason why its disabled by default - Fix in a pr if you have time! - https://cdn.discordapp.com/attachments/810446565822038016/858851144750989312/jbIAkzJ9CU.mp4
            if (getConfig().getBoolean("LookForIllegalsInShulkers") && ItemUtils.isShulkerBox(item)) {
                BlockStateMeta meta = (BlockStateMeta) item.getItemMeta();
                ShulkerBox box = (ShulkerBox) meta.getBlockState();

                box.getInventory().forEach(this::revert);

                box.update();
                meta.setBlockState(box);
                item.setItemMeta(meta);
            }

            if (getConfig().getBoolean("RevertStackedItems")) {
                if (getConfig().getBoolean("OnlyRevertStacksForCertainItems")) {
                    for (String s : getConfig().getStringList("RevertStackedItemsList")) {
                        if (item.getType().name().equals(s) && item.getAmount() > item.getMaxStackSize()) {
                            item.setAmount(item.getMaxStackSize());
                        }
                    }
                } else {
                    if (item.getAmount() > item.getMaxStackSize()) {
                        item.setAmount(item.getMaxStackSize());
                    }
                }
            }

            if (getConfig().getBoolean("RevertUnbreakables.Enabled")) {
                if (getConfig().getBoolean("RevertUnbreakables.EnableWhitelist")) {
                    if (getConfig().getStringList("RevertUnbreakables.Whitelist").contains(item.getType().name())) {
                        if (!getConfig().getBoolean("RevertUnbreakables.SkipZeroDurability") || item.getType().getMaxDurability() != 0) {
                            if (item.getDurability() > item.getType().getMaxDurability()) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                            if (item.getDurability() < 0) {
                                item.subtract(item.getAmount());
                            }
                        } else {
                            if (item.getDurability() > 2031) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                        }
                    }
                } else {
                    if (!getConfig().getStringList("ItemsSkipped").contains(item.getType().name())) {
                        if (!getConfig().getBoolean("RevertUnbreakables.SkipZeroDurability") || item.getType().getMaxDurability() != 0) {
                            if (item.getDurability() > item.getType().getMaxDurability()) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                            if (item.getDurability() < 0) {
                                item.subtract(item.getAmount());
                            }
                        } else {
                            if (item.getDurability() > 2031) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                        }
                    }
                }
            }

            if (getConfig().getBoolean("RevertEnchantments"))
                revertEnchantments(item);

            if (getConfig().getBoolean("RemoveIllegalHeads") && item.getType().equals(Material.SKULL_ITEM)) {
                SkullMeta sm = (SkullMeta) item.getItemMeta();

                if (sm.hasOwner() || item.getData().toString().equals("SKULL_ITEM(3)")) {
                    item.subtract(item.getAmount());
                }
            }

            if (getConfig().getBoolean("RemoveSpawnEggs") && item.getType() == Material.MONSTER_EGG)
                item.subtract(item.getAmount());

            if (getConfig().getStringList("BANNED_BLOCKS").contains(item.getType().name()))
                item.subtract(item.getAmount());
            if (getConfig().getStringList("BANNED_NAMES").contains(item.getI18NDisplayName()))
                item.subtract(item.getAmount());
            if (getConfig().getBoolean("DataValues.RevertSpecificDataValues")) {
                if (getConfig().getStringList("DataValues.SpecificDataValues").contains(item.getData().toString())) {
                    item.subtract(item.getAmount());
                }
                if (getConfig().getBoolean("DataValues.RevertIllegalGoldenApple")) {
                    if (item.getType().name().equals("GOLDEN_APPLE")) {
                        if (!item.getData().toString().equals("GOLDEN_APPLE(0)") && !item.getData().toString().equals("GOLDEN_APPLE(1)") && !item.getData().toString().equals("GOLDEN_APPLE0") && !item.getData().toString().equals("LEGACY_GOLDEN_APPLE(0)") && !item.getData().toString().equals("LEGACY_GOLDEN_APPLE(1)")) {
                            item.subtract(item.getAmount());
                        }
                    }
                }
            }
        }
    }

    private void revertEnchantments(ItemStack item) {
        if (!getConfig().getStringList("ItemsSkipped").contains(item.getType().name())) {
            for (Map.Entry<Enchantment, Integer> entry : item.getEnchantments().entrySet()) {
                if (entry.getValue() != null && entry.getKey() != null) {
                    if (getConfig().getBoolean("RevertSpecificEnchantments")) {
                        for (String s : getConfig().getStringList("SpecificEnchantments")) {
                            if (entry.getKey().getName().contains(s)) {
                                if (entry.getValue() > entry.getKey().getMaxLevel()) {
                                    replaceEnchantment(item, entry.getKey(), entry.getKey().getMaxLevel());
                                } else {
                                    if (!entry.getKey().canEnchantItem(item)) {
                                        item.removeEnchantment(entry.getKey());
                                    }
                                }
                            }

                        }
                    } else {
                        if (entry.getValue() > entry.getKey().getMaxLevel()) {
                            replaceEnchantment(item, entry.getKey(), entry.getKey().getMaxLevel());
                        } else {
                            if (!entry.getKey().canEnchantItem(item)) {
                                item.removeEnchantment(entry.getKey());
                            }
                        }
                    }
                }
            }
        }
    }

    public void preventDespawning() {
        for (World w : Bukkit.getWorlds()) {
            for (Entity e : w.getEntities()) {
                if (e instanceof LivingEntity) {
                    ((LivingEntity) e).setRemoveWhenFarAway(!isEntityCloseToPlayer(e));
                }
            }
        }
    }

    public boolean isEntityCloseToPlayer(Entity entity) {
        for (Player player : Bukkit.getOnlinePlayers()) {
            Point p1 = new Point(player.getLocation().getBlockX(), player.getLocation().getBlockZ());
            Point p2 = new Point(entity.getLocation().getBlockX(), entity.getLocation().getBlockZ());
            if (p1.distance(p2) < 500) {
                return true;
            }
        }
        return false;
    }

    public Integer countVehicles(Entity[] entities) {
        Integer count = 0;
        for (Entity entity : entities) {
            if (entity instanceof Vehicle) {
                count++;
            }
        }
        return count;
    }

    private void register(Listener... list) {
        pluginManager.registerEvents(this, this);
        for (Listener listener : list) {
            if (getConfig().getStringList("DisabledClasses").contains(listener.getClass().getSimpleName())) {
                getLogger().warning("Skipped loading class " + listener.getClass().getSimpleName() + " because disabled in config.");
            } else {
                pluginManager.registerEvents(listener, this);
                getLogger().info("Loaded class " + listener.getClass().getSimpleName());
            }
        }
    }

    public static LanguageCache getLang(String lang) {
        lang = lang.replace("-", "_");
        if (configCache.auto_lang) {
            return languageCacheMap.getOrDefault(lang, languageCacheMap.get(configCache.default_lang.toString().toLowerCase()));
        } else {
            return languageCacheMap.get(configCache.default_lang.toString().toLowerCase());
        }
    }

    public static LanguageCache getLang(Locale locale) {
        return getLang(locale.toString().toLowerCase());
    }

    public static LanguageCache getLang(CommandSender commandSender) {
        if (commandSender instanceof Player) {
            Player player = (Player) commandSender;
            return getLang(player.getLocale());
        } else {
            return getLang(configCache.default_lang);
        }
    }

    public void reloadAEFConfig() {
        saveDefaultConfig();
        reloadConfig();
        configCache = new Config();
        AnarchyExploitFixesModule.reloadModules();
        configCache.saveConfig();
    }

    public void reloadLang() {
        languageCacheMap = new HashMap<>();
        try {
            File langDirectory = new File(instance.getDataFolder() + File.separator + "lang");
            Files.createDirectories(langDirectory.toPath());
            for (String fileName : getDefaultLanguageFiles()) {
                String localeString = fileName.substring(fileName.lastIndexOf('/') + 1, fileName.lastIndexOf('.'));
                getLogger().info(String.format("Found language file for %s", localeString));
                LanguageCache langCache = new LanguageCache(localeString);
                languageCacheMap.put(localeString, langCache);
            }
            Pattern langPattern = Pattern.compile("([a-z]{1,3}_[a-z]{1,3})(\\.yml)", Pattern.CASE_INSENSITIVE);
            for (File langFile : langDirectory.listFiles()) {
                Matcher langMatcher = langPattern.matcher(langFile.getName());
                if (langMatcher.find()) {
                    String localeString = langMatcher.group(1).toLowerCase();
                    if(!languageCacheMap.containsKey(localeString)) { // make sure it wasn't a default file that we already loaded
                        getLogger().info(String.format("Found language file for %s", localeString));
                        LanguageCache langCache = new LanguageCache(localeString);
                        languageCacheMap.put(localeString, langCache);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
            getLogger().severe("Error loading language files! Language files will not reload to avoid errors, make sure to correct this before restarting the server!");
        }
    }

    private Set<String> getDefaultLanguageFiles(){
        Reflections reflections = new Reflections("lang", Scanners.Resources);
        return reflections.getResources(Pattern.compile("([a-z]{1,3}_[a-z]{1,3})(\\.yml)"));
    }

    public static AnarchyExploitFixes getInstance()  {
        return instance;
    }

    public static Config getConfiguration() {
        return configCache;
    }
}
