package me.moomoo.anarchyexploitfixes.utils;

import com.cryptomorin.xseries.XMaterial;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.block.ShulkerBox;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.SkullMeta;

import java.util.Map;

public class ItemUtils {
    private ItemUtils() {}

    public static boolean isBook(ItemStack item) {
        switch (XMaterial.matchXMaterial(item)) {
            case WRITABLE_BOOK:
            case WRITTEN_BOOK:
                return true;
            default:
                return false;
        }
    }

    public static boolean isShulkerBox(ItemStack item) {
        switch (XMaterial.matchXMaterial(item)) {
            case SHULKER_BOX:
            case BLACK_SHULKER_BOX:
            case BLUE_SHULKER_BOX:
            case BROWN_SHULKER_BOX:
            case CYAN_SHULKER_BOX:
            case GRAY_SHULKER_BOX:
            case GREEN_SHULKER_BOX:
            case LIGHT_BLUE_SHULKER_BOX:
            case LIGHT_GRAY_SHULKER_BOX:
            case LIME_SHULKER_BOX:
            case MAGENTA_SHULKER_BOX:
            case ORANGE_SHULKER_BOX:
            case PINK_SHULKER_BOX:
            case PURPLE_SHULKER_BOX:
            case RED_SHULKER_BOX:
            case WHITE_SHULKER_BOX:
            case YELLOW_SHULKER_BOX:
                return true;
            default:
                return false;
        }
    }

    public void revert(ItemStack item) {
        if (item != null) {
            // Warning: Enables a dupe exploit, reason why its disabled by default - Fix in a pr if you have time! - https://cdn.discordapp.com/attachments/810446565822038016/858851144750989312/jbIAkzJ9CU.mp4
            if (getConfig().getBoolean("LookForIllegalsInShulkers") && ItemUtils.isShulkerBox(item)) {
                BlockStateMeta meta = (BlockStateMeta) item.getItemMeta();
                ShulkerBox box = (ShulkerBox) meta.getBlockState();

                box.getInventory().forEach(this::revert);

                box.update();
                meta.setBlockState(box);
                item.setItemMeta(meta);
            }

            if (getConfig().getBoolean("RevertStackedItems")) {
                if (getConfig().getBoolean("OnlyRevertStacksForCertainItems")) {
                    for (String s : getConfig().getStringList("RevertStackedItemsList")) {
                        if (item.getType().name().equals(s) && item.getAmount() > item.getMaxStackSize()) {
                            item.setAmount(item.getMaxStackSize());
                        }
                    }
                } else {
                    if (item.getAmount() > item.getMaxStackSize()) {
                        item.setAmount(item.getMaxStackSize());
                    }
                }
            }

            if (getConfig().getBoolean("RevertUnbreakables.Enabled")) {
                if (getConfig().getBoolean("RevertUnbreakables.EnableWhitelist")) {
                    if (getConfig().getStringList("RevertUnbreakables.Whitelist").contains(item.getType().name())) {
                        if (!getConfig().getBoolean("RevertUnbreakables.SkipZeroDurability") || item.getType().getMaxDurability() != 0) {
                            if (item.getDurability() > item.getType().getMaxDurability()) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                            if (item.getDurability() < 0) {
                                item.subtract(item.getAmount());
                            }
                        } else {
                            if (item.getDurability() > 2031) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                        }
                    }
                } else {
                    if (!getConfig().getStringList("ItemsSkipped").contains(item.getType().name())) {
                        if (!getConfig().getBoolean("RevertUnbreakables.SkipZeroDurability") || item.getType().getMaxDurability() != 0) {
                            if (item.getDurability() > item.getType().getMaxDurability()) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                            if (item.getDurability() < 0) {
                                item.subtract(item.getAmount());
                            }
                        } else {
                            if (item.getDurability() > 2031) {
                                item.setDurability(item.getType().getMaxDurability());
                            }
                        }
                    }
                }
            }

            if (getConfig().getBoolean("RevertEnchantments"))
                revertEnchantments(item);

            if (getConfig().getBoolean("RemoveIllegalHeads") && item.getType().equals(Material.SKULL_ITEM)) {
                SkullMeta sm = (SkullMeta) item.getItemMeta();

                if (sm.hasOwner() || item.getData().toString().equals("SKULL_ITEM(3)")) {
                    item.subtract(item.getAmount());
                }
            }

            if (getConfig().getBoolean("RemoveSpawnEggs") && item.getType() == Material.MONSTER_EGG)
                item.subtract(item.getAmount());

            if (getConfig().getStringList("BANNED_BLOCKS").contains(item.getType().name()))
                item.subtract(item.getAmount());
            if (getConfig().getStringList("BANNED_NAMES").contains(item.getI18NDisplayName()))
                item.subtract(item.getAmount());
            if (getConfig().getBoolean("DataValues.RevertSpecificDataValues")) {
                if (getConfig().getStringList("DataValues.SpecificDataValues").contains(item.getData().toString())) {
                    item.subtract(item.getAmount());
                }
                if (getConfig().getBoolean("DataValues.RevertIllegalGoldenApple")) {
                    if (item.getType().name().equals("GOLDEN_APPLE")) {
                        if (!item.getData().toString().equals("GOLDEN_APPLE(0)") && !item.getData().toString().equals("GOLDEN_APPLE(1)") && !item.getData().toString().equals("GOLDEN_APPLE0") && !item.getData().toString().equals("LEGACY_GOLDEN_APPLE(0)") && !item.getData().toString().equals("LEGACY_GOLDEN_APPLE(1)")) {
                            item.subtract(item.getAmount());
                        }
                    }
                }
            }
        }
    }

    private void revertEnchantments(ItemStack item) {
        if (!getConfig().getStringList("ItemsSkipped").contains(item.getType().name())) {
            for (Map.Entry<Enchantment, Integer> entry : item.getEnchantments().entrySet()) {
                if (entry.getValue() != null && entry.getKey() != null) {
                    if (getConfig().getBoolean("RevertSpecificEnchantments")) {
                        for (String s : getConfig().getStringList("SpecificEnchantments")) {
                            if (entry.getKey().getName().contains(s)) {
                                if (entry.getValue() > entry.getKey().getMaxLevel()) {
                                    replaceEnchantment(item, entry.getKey(), entry.getKey().getMaxLevel());
                                } else {
                                    if (!entry.getKey().canEnchantItem(item)) {
                                        item.removeEnchantment(entry.getKey());
                                    }
                                }
                            }

                        }
                    } else {
                        if (entry.getValue() > entry.getKey().getMaxLevel()) {
                            replaceEnchantment(item, entry.getKey(), entry.getKey().getMaxLevel());
                        } else {
                            if (!entry.getKey().canEnchantItem(item)) {
                                item.removeEnchantment(entry.getKey());
                            }
                        }
                    }
                }
            }
        }
    }

    public void replaceEnchantment(ItemStack item, Enchantment enchantment, Integer level) {
        item.removeEnchantment(enchantment);

        if (enchantment.canEnchantItem(item)) {
            item.addEnchantment(enchantment, level);
        } else {
            if (!getConfig().getBoolean("RevertUnEnchantable"))
                item.addUnsafeEnchantment(enchantment, level);
        }
    }

    if (getConfig().getBoolean("StrictIllegalPrevention")) {
        Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(world -> world.getPlayers().forEach(player -> player.getInventory().forEach(this::revert))), 0L, 20L);
    }
}