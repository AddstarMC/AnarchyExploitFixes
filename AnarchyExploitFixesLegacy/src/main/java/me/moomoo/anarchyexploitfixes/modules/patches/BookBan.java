package me.moomoo.anarchyexploitfixes.modules.patches;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;
import me.moomoo.anarchyexploitfixes.utils.MaterialUtil;
import org.bukkit.Material;
import org.bukkit.block.ShulkerBox;
import org.bukkit.entity.Item;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.*;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.UUID;

public class BookBan implements AEFModule, Listener {

    private final Cache<UUID, Integer> cachedItemSizes, cachedInventorySizes;
    private final int maxBookSize, maxItemSize, maxInventorySize, maxAuthorChars, maxTitleChars, maxPages;
    private final boolean useUTF16, kickOnBigBook;

    public BookBan() {
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        this.useUTF16 = config.getBoolean("patches.anti-book-ban.use-UTF-16", false,
                "If set to false, will use UTF-8.\n" +
                        "Charset to use to encode the result of ItemMeta#toString into a sequence of bytes.\n" +
                        "The length of that sequence is then used to get the approximate Byte-size of an ItemStack.");
        this.maxBookSize = config.getInt("patches.anti-book-ban.max-book-size", 8000);
        this.kickOnBigBook = config.getBoolean("patches.anti-book-ban.kick-on-too-large-book-edit", true,
                "Kicks players when they try to create a book bigger than the limit.");
        this.maxAuthorChars = config.getInt("patches.anti-book-ban.max-author-chars", 32);
        this.maxTitleChars = config.getInt("patches.anti-book-ban.max-title-chars", 32);
        this.maxPages = config.getInt("patches.anti-book-ban.max-pages", 100);
        this.maxItemSize = config.getInt("patches.anti-book-ban.max-item-size", 8260);
        this.maxInventorySize = config.getInt("patches.anti-book-ban.max-inventory-size", 50674);
        this.cachedItemSizes = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                Math.max(1, config.getInt("patches.anti-book-ban.dropped-items-size-cache-ticks", 120,
                        "How long in ticks a dropped item's size should be cached after checking.")) * 50L
        )).build();
        this.cachedInventorySizes = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                Math.max(1, config.getInt("patches.anti-book-ban.player-inventory-size-cache-ticks", 20,
                        "How long in ticks a player's inventory size should be cached after checking.")) * 50L
        )).build();
    }

    @Override
    public String name() {
        return "anti-book-ban";
    }

    @Override
    public String category() {
        return "patches";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("patches.anti-book-ban.enable", true);
    }

    private int getItemSize(ItemStack stack) {
        int byteSize = 0;
        if (stack == null || !stack.hasItemMeta()) return byteSize;

        final Material material = stack.getType();

        if (MaterialUtil.SHULKER_BOXES.contains(material)) {
            byteSize += this.getInventorySize(((ShulkerBox) ((BlockStateMeta) stack.getItemMeta()).getBlockState()).getInventory());
            return byteSize;
        }

        if (MaterialUtil.BOOKS.contains(material)) {
            byteSize += this.getBookSize((BookMeta) stack.getItemMeta());
            return byteSize;
        }

        // Expensive
        byteSize += stack.getItemMeta().toString().getBytes(useUTF16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length;
        return byteSize;
    }

    private int getInventorySize(Iterable<ItemStack> inventory) {
        int collectiveSize = 0;
        for (ItemStack stack : inventory) {
            collectiveSize += getItemSize(stack);
        }
        return collectiveSize;
    }

    private int getBookSize(BookMeta bookMeta) {
        String content = String.join("", bookMeta.getPages());
        if (bookMeta.hasTitle())
            content = String.join("", content, bookMeta.getTitle());
        if (bookMeta.hasAuthor())
            content = String.join("", content, bookMeta.getAuthor());
        return content.getBytes(useUTF16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length;
    }

    // Prevent players from creating big books
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBookEdit(PlayerEditBookEvent event) {
        BookMeta meta = event.getNewBookMeta();

        if (
                (meta.hasAuthor() && meta.getAuthor().length() > maxAuthorChars)
                || (meta.hasTitle() && meta.getTitle().length() > maxTitleChars)
                || (meta.hasPages() && meta.getPages().size() > maxPages)
        ) {
            event.setCancelled(true);
            return;
        }

        if (this.getBookSize(meta) > maxBookSize) {
            event.setCancelled(true);
            if (kickOnBigBook) {
                final Player player = event.getPlayer();
                player.kickPlayer(AnarchyExploitFixes.getLang(player.getLocale()).misc_MaskedKickMessage);
            }
        }
    }

    // Attempt to stop players from picking up large items
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        // Check if item is generally over the size limit
        final Item item = event.getItem();
        Integer itemSize = this.cachedItemSizes.getIfPresent(item.getUniqueId());
        if (itemSize == null) {
            itemSize = this.getItemSize(item.getItemStack());
            this.cachedItemSizes.put(item.getUniqueId(), itemSize);
        }
        // If item is bigger than allowed, disallow player picking it up
        if (itemSize > maxItemSize) {
            event.setCancelled(true);
            return;
        }

        // Check if the total inventory size would be larger than the maximum inventory size
        final Player player = event.getPlayer();
        Integer invSize = this.cachedInventorySizes.getIfPresent(player.getUniqueId());
        if (invSize == null) {
            invSize = this.getInventorySize(player.getInventory());
            this.cachedInventorySizes.put(player.getUniqueId(), invSize);
        }
        // If picking up item would exceed max inventory size, disallow player picking it up
        if (itemSize + invSize > maxInventorySize) {
            event.setCancelled(true);
        }
    }

    private void sanitizeInventory(Iterable<ItemStack> inventory) {
        for (ItemStack item : inventory) {
            if (this.getItemSize(item) > maxItemSize) {
                item.subtract(item.getAmount());
            }
        }
    }

    // Attempt to clear off big items from affected players
    @EventHandler(priority = EventPriority.LOW)
    private void onJoin(PlayerJoinEvent event) {
        this.sanitizeInventory(event.getPlayer().getInventory());
    }

    @EventHandler(priority = EventPriority.LOW)
    private void onLeave(PlayerQuitEvent event) {
        this.sanitizeInventory(event.getPlayer().getInventory());
    }

    @EventHandler(priority = EventPriority.LOW)
    private void onKick(PlayerKickEvent event) {
        this.sanitizeInventory(event.getPlayer().getInventory());
    }
}