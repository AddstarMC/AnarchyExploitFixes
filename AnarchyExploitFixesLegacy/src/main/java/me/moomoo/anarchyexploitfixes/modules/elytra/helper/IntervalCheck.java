package me.moomoo.anarchyexploitfixes.modules.elytra.helper;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.utils.LocationUtil;
import org.bukkit.Location;
import org.bukkit.entity.Player;

import java.time.Duration;
import java.util.UUID;

public class IntervalCheck extends ElytraHelper implements Runnable {

    public final Cache<UUID, Double> PLAYER_SPEEDS;
    public final Cache<UUID, Location> LAST_GLIDE_POS;
    private final int checkIntervalTicks;
    public final boolean isEnabled;

    public IntervalCheck() {
        Config config = AnarchyExploitFixes.getConfiguration();
        this.isEnabled = config.getBoolean("elytra.patch-generic-speedhacks.enable", true,
                "Patches speed-limit bypass using generic speedhacks (Timer) by additionally checking player position every x ticks");
        final int tickInterval = config.getInt("elytra.patch-generic-speedhacks.check-interval-in-ticks", 10,
                "Lower value means more accuracy but also more overhead.");
        this.checkIntervalTicks = Math.max(tickInterval, 1);
        final Duration cacheTime = Duration.ofMillis(Math.max(1000, (tickInterval * 50L) + 100L));
        this.PLAYER_SPEEDS = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        this.LAST_GLIDE_POS = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();

    }

    public void startIfEnabled() {
        if (isEnabled) super.plugin.getServer().getScheduler().scheduleSyncRepeatingTask(plugin, this, checkIntervalTicks, checkIntervalTicks);
    }

    @Override
    public void run() {
        for (Player player : super.plugin.getServer().getOnlinePlayers()) {
            if (this.isGliding(player)) {
                Location currentLocation = player.getLocation().clone();
                Location lastLocation = LAST_GLIDE_POS.getIfPresent(player.getUniqueId());
                if (lastLocation != null) this.PLAYER_SPEEDS.put(
                        player.getUniqueId(),
                        calculate3D ? LocationUtil.getRelDistance3D(lastLocation, currentLocation) : LocationUtil.getRelDistance2D(lastLocation, currentLocation) / checkIntervalTicks
                );
                LAST_GLIDE_POS.put(player.getUniqueId(), currentLocation);
            }
        }
    }
}
