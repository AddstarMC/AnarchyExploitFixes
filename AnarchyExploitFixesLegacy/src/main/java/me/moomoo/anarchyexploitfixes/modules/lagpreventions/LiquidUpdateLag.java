package me.moomoo.anarchyexploitfixes.modules.lagpreventions;

import com.cryptomorin.xseries.XMaterial;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.utils.LogUtils;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockFromToEvent;
import org.bukkit.event.world.ChunkUnloadEvent;

import java.util.HashMap;
import java.util.logging.Level;

public class LiquidUpdateLag implements AnarchyExploitFixesModule, Listener {

    private final HashMap<String, Long> cooldowns = new HashMap<>();
    private final HashMap<String, Integer> liquidEventCounts = new HashMap<>();
    private final boolean logIsEnabled;
    private final int maxLiquidSpreadEventsPerChunk;
    private final long liquidSpreadCooldownInMillis;
    private final Material dragon_egg;

    public LiquidUpdateLag() {
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        this.maxLiquidSpreadEventsPerChunk = config.getInt("lag-preventions.prevent-liquid-update-lag.max-liquid-events-in-same-chunk-per-time", 1200, "amount of liquid source blocks * sides it can spread to * block spread length");
        this.liquidSpreadCooldownInMillis = config.getInt("lag-preventions.prevent-liquid-update-lag.time-in-ticks", 100, "Record time after first liquid spread. \nWhen this time runs out, the spread counter resets") * 50L;
        this.logIsEnabled = config.getBoolean("lag-preventions.prevent-liquid-update-lag.log", false, "very spammy, use for testing only");
        this.dragon_egg = XMaterial.DRAGON_EGG.parseMaterial();
    }

    @Override
    public String name() {
        return "prevent-liquid-update-lag";
    }

    @Override
    public String category() {
        return "lag-preventions";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        plugin.getServer().getScheduler().runTaskTimerAsynchronously(plugin, () -> {
            cooldowns.clear();
            liquidEventCounts.clear();
        }, 2000L, 2000L);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("lag-preventions.prevent-liquid-update-lag.enable", false);
    }

    @EventHandler(priority = EventPriority.LOWEST, ignoreCancelled = true)
    private void onLiquidSpread(BlockFromToEvent event) {
        Block sourceBlock = event.getBlock();
        if (sourceBlock.getType().equals(dragon_egg)) return; // Event fires only for liquids and the dragon egg

        final Chunk chunk = sourceBlock.getChunk();
        final String chunkId = String.valueOf(chunk.getWorld().getUID()) + chunk.getChunkKey();
        final long currentTime = System.currentTimeMillis();

        if (!liquidEventCounts.containsKey(chunkId) || !cooldowns.containsKey(chunkId)) {
            liquidEventCounts.put(chunkId, 1);
            cooldowns.put(chunkId, currentTime);
            return;
        }

        int liquidEventCount = liquidEventCounts.get(chunkId);

        if (liquidEventCount >= maxLiquidSpreadEventsPerChunk) {
            if (currentTime - cooldowns.get(chunkId) < liquidSpreadCooldownInMillis) {
                event.setCancelled(true);
                if (logIsEnabled) LogUtils.moduleLog(Level.INFO, name(), "Cancelled liquid events for chunk x:" + chunk.getX() + ", z:" + chunk.getZ() + "in world: " + chunk.getWorld().getName());
                return;
            }

            liquidEventCount = 1;
        }

        liquidEventCount++;
        if (logIsEnabled) LogUtils.moduleLog(Level.INFO, name(), " Recorded " + liquidEventCount + " liquid updates in chunk x:" + chunk.getX() + ", z:" + chunk.getZ() + ", world: " + chunk.getWorld().getName());

        liquidEventCounts.put(chunkId, liquidEventCount);
        cooldowns.put(chunkId, currentTime);
    }

    @EventHandler(priority = EventPriority.NORMAL, ignoreCancelled = true)
    private void onChunkUnload(ChunkUnloadEvent event) {
        String chunkId = String.valueOf(event.getChunk().getWorld().getUID()) + event.getChunk().getChunkKey();
        liquidEventCounts.remove(chunkId);
        cooldowns.remove(chunkId);
    }
}
