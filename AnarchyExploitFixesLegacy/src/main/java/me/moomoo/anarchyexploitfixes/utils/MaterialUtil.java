package me.moomoo.anarchyexploitfixes.utils;

import com.cryptomorin.xseries.XMaterial;
import com.cryptomorin.xseries.XTag;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;
import java.util.HashSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class MaterialUtil {

    public static final HashSet<Material> INDESTRUCTIBLES = Stream.of(
            XMaterial.BEDROCK,
            XMaterial.END_PORTAL_FRAME,
            XMaterial.END_PORTAL,
            XMaterial.REINFORCED_DEEPSLATE,
            XMaterial.STRUCTURE_BLOCK,
            XMaterial.STRUCTURE_VOID,
            XMaterial.BARRIER,
            XMaterial.COMMAND_BLOCK
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> BOOKS = Stream.of(
            XMaterial.WRITABLE_BOOK,
            XMaterial.WRITTEN_BOOK
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> SHULKER_BOXES = Stream.of(
            XMaterial.SHULKER_BOX,
            XMaterial.BLACK_SHULKER_BOX,
            XMaterial.BLUE_SHULKER_BOX,
            XMaterial.BROWN_SHULKER_BOX,
            XMaterial.CYAN_SHULKER_BOX,
            XMaterial.GRAY_SHULKER_BOX,
            XMaterial.GREEN_SHULKER_BOX,
            XMaterial.LIGHT_BLUE_SHULKER_BOX,
            XMaterial.LIGHT_GRAY_SHULKER_BOX,
            XMaterial.LIME_SHULKER_BOX,
            XMaterial.MAGENTA_SHULKER_BOX,
            XMaterial.ORANGE_SHULKER_BOX,
            XMaterial.PINK_SHULKER_BOX,
            XMaterial.PURPLE_SHULKER_BOX,
            XMaterial.RED_SHULKER_BOX,
            XMaterial.WHITE_SHULKER_BOX,
            XMaterial.YELLOW_SHULKER_BOX
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static boolean isShulkerBox(ItemStack item) {
        if (item == null) return false;
        return SHULKER_BOXES.contains(item.getType());
    }

    public static boolean isShulkerBox(Material material) {
        if (material == null) return false;
        return SHULKER_BOXES.contains(material);
    }

    public static final HashSet<Material> HELMETS = Stream.of(
            XMaterial.NETHERITE_HELMET,
            XMaterial.DIAMOND_HELMET,
            XMaterial.TURTLE_HELMET,
            XMaterial.GOLDEN_HELMET,
            XMaterial.IRON_HELMET,
            XMaterial.LEATHER_HELMET,
            XMaterial.CHAINMAIL_HELMET
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> CHESTPLATES = Stream.of(
             XMaterial.NETHERITE_CHESTPLATE,
             XMaterial.DIAMOND_CHESTPLATE,
             XMaterial.GOLDEN_CHESTPLATE,
             XMaterial.IRON_CHESTPLATE,
             XMaterial.LEATHER_CHESTPLATE,
             XMaterial.CHAINMAIL_CHESTPLATE
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> LEGGINGS = Stream.of(
             XMaterial.NETHERITE_LEGGINGS,
             XMaterial.DIAMOND_LEGGINGS,
             XMaterial.GOLDEN_LEGGINGS,
             XMaterial.IRON_LEGGINGS,
             XMaterial.LEATHER_LEGGINGS,
             XMaterial.CHAINMAIL_LEGGINGS
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> BOOTS = Stream.of(
            XMaterial.NETHERITE_BOOTS,
            XMaterial.DIAMOND_BOOTS,
            XMaterial.GOLDEN_BOOTS,
            XMaterial.IRON_BOOTS,
            XMaterial.LEATHER_BOOTS,
            XMaterial.CHAINMAIL_BOOTS
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> AXES = Stream.of(
            XMaterial.NETHERITE_AXE,
            XMaterial.DIAMOND_AXE,
            XMaterial.GOLDEN_AXE,
            XMaterial.IRON_AXE,
            XMaterial.STONE_AXE,
            XMaterial.WOODEN_AXE
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> HOES = Stream.of(
            XMaterial.NETHERITE_HOE,
            XMaterial.DIAMOND_HOE,
            XMaterial.GOLDEN_HOE,
            XMaterial.IRON_HOE,
            XMaterial.STONE_HOE,
            XMaterial.WOODEN_HOE
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> PICKAXES = Stream.of(
            XMaterial.NETHERITE_PICKAXE,
            XMaterial.DIAMOND_PICKAXE,
            XMaterial.GOLDEN_PICKAXE,
            XMaterial.IRON_PICKAXE,
            XMaterial.STONE_PICKAXE,
            XMaterial.WOODEN_PICKAXE
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> SHOVELS = Stream.of(
            XMaterial.NETHERITE_SHOVEL,
            XMaterial.DIAMOND_SHOVEL,
            XMaterial.GOLDEN_SHOVEL,
            XMaterial.IRON_SHOVEL,
            XMaterial.STONE_SHOVEL,
            XMaterial.WOODEN_SHOVEL
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> SWORDS = Stream.of(
            XMaterial.NETHERITE_SWORD,
            XMaterial.DIAMOND_SWORD,
            XMaterial.GOLDEN_SWORD,
            XMaterial.IRON_SWORD,
            XMaterial.STONE_SWORD,
            XMaterial.WOODEN_SWORD
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> SPAWN_EGGS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> {
                if (xMaterial.isSupported()) {
                    final String name = xMaterial.name().toUpperCase();
                    return name.contains("SPAWN_EGG") || name.contains("MONSTER_EGG");
                }
                return false;
            })
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static boolean isSpawnEgg(ItemStack item) {
        if (item == null) return false;
        return SPAWN_EGGS.contains(item.getType());
    }

    public static final HashSet<Material> PISTONS = Stream.of(
            XMaterial.PISTON,
            XMaterial.PISTON_HEAD,
            XMaterial.MOVING_PISTON,
            XMaterial.STICKY_PISTON
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> ANVILS = XTag.ANVIL.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final HashSet<Material> LIQUID_BUCKETS = Stream.of(
            XMaterial.WATER_BUCKET,
            XMaterial.LAVA_BUCKET,
            XMaterial.COD_BUCKET,
            XMaterial.SALMON_BUCKET,
            XMaterial.PUFFERFISH_BUCKET,
            XMaterial.TROPICAL_FISH_BUCKET,
            XMaterial.AXOLOTL_BUCKET,
            XMaterial.TADPOLE_BUCKET,
            XMaterial.POWDER_SNOW_BUCKET
    ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static boolean isArmor(ItemStack item) {
        if (item == null) return false;
        return isArmor(item.getType());
    }

    public static boolean isArmor(Material material) {
        if (material == null) return false;
        return HELMETS.contains(material) || CHESTPLATES.contains(material) || LEGGINGS.contains(material) || BOOTS.contains(material);
    }

    public static boolean isTool(ItemStack item) {
        if (item == null) return false;
        return isTool(item.getType());
    }

    public static boolean isTool(Material material) {
        if (material == null) return false;
        return AXES.contains(material) || HOES.contains(material) || PICKAXES.contains(material) || SHOVELS.contains(material);
    }

    private static final Material ELYTRA = XMaterial.ELYTRA.parseMaterial();
    public static boolean isElytra(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(ELYTRA);
    }

    private static final Material TRIDENT = XMaterial.TRIDENT.parseMaterial();
    public static boolean isTrident(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(TRIDENT);
    }

    private static final Material CROSSBOW = XMaterial.CROSSBOW.parseMaterial();
    public static boolean isCrossbow(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(CROSSBOW);
    }

    private static final Material BOW = XMaterial.BOW.parseMaterial();
    public static boolean isBow(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(BOW);
    }

    private static final Material BUNDLE = XMaterial.BUNDLE.parseMaterial();
    public static boolean isBundle(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(BUNDLE);
    }
}